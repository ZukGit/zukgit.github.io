---
layout: post
title: 排序算法总结
category: 思考
tags: IT Portocol
keywords: 
typora-root-url:..\..\
typora-copy-images-to:..\..\public\zimage
---

## 简介
 * TOC
 {:toc}
## 排序算法总结



排序算法是《数据结构与算法》中最基本的算法之一。

排序算法可以分为【内部排序】和【外部排序】

```
内部排序:   数据记录在内存中进行排序。

外部排序:   是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。



常见内部排序算法：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等
https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md
```


### 排序算法表格
<img src="/public/zimage/architect/01_sorttable.jpg">


### 时间复杂度推理
```
算法的时间复杂度是一个函数，它定性描述了该算法的运行时间
时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况

计数排序,桶排序 都需要花费很多内存空间,当数值数量N过多时,内存消耗过大


关于时间复杂度：N=10时 K=5时 (对10个数字中找到最大的5个)
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【10^2 = 100】
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【10*log(2)10 = 33.2】
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                  【 10^1.25 = 17.782】
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 10+5 = 15】
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 10*5 = 50】



关于时间复杂度：N=100时 K=50时 (对10个数字中找到最大的5个)
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【100^2 = 10000】一万
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【100*log(2)100 = 664】  六百六
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                  【 100^1.25 = 316】  三百
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 100+50 = 150】 一百五
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 100*50 = 5000】五千



关于时间复杂度：N=1000时 K=500时 (对1000个数字中找到最大的500个)
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【1000^2   =  1000000】一百万
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【1000*log(2)*1000 =   9965】  一万
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                    【 1000^1.25 =     5623】五千六
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 1000+500 =     1500】一千五
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 1000*500 =   500000】五十万




关于时间复杂度：N=10000时 K=5000时 (对10000个数字中找到最大的5000个)  N=1万  K=5千
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【10000^2   =  1000000000】一亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【10000*log(2)*10000 =   132877】十三万
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                    【 10000^(1.25)  =     100000】十万
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 10000+5000 =     15000】一万五
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 10000*5000 =   50000000】五千万




关于时间复杂度：N=100000 时 K=50000 时 (对100000个数字中找到最大的50000个)  N=10万  K=5万
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【100000^2   =  1000000000】一百亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【100000*log(2)*100000 =   1660964】166万
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                    【 100000^(1.25) =     1778279】177万
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 100000+50000 =     15000】15万
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 100000*50000 =   50000000】五十亿



关于时间复杂度：N=1000000 时 K=500000 时 (对 1000000 个数字中找到最大的 500000 个)  N=100万  K=50万
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【100000^2   =  1000000000】一万亿       
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【100000*log(2)100000 =   1660964】1993万
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                    【 1000000^(1.25) =     31622776】3162万
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 1000000+500000 =     15000】150万
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 1000000*500000 =   50000000】五千亿   



关于时间复杂度：N=10000000 时 K=5000000 时 (对 10000000 个数字中找到最大的 5000000 个)  N=1000万  K=500万
1. 【O(n²)】          ---平方阶排序: 【冒泡排序, 选择排序, 插入排序】        【1000000^2   =  1000000000】100万亿   ■ 第1组 出局■
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【1000000*log(2)1000000 =   232534966】2.3亿
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                    【 10000000^(1.25) =      562341325 】5.6亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 10000000+5000000 =     15000】1500万
5. 【O(kn)】-------------- 高线性阶排序： 【基数排序】                      【 10000000*500000 =   50000000】50万亿   ■ 第5组 出局■ 


关于时间复杂度：N=100000000 时 K=50000000时 (对100000个数字中找到最大的50000个)  N=1亿  K=0.5亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【100000000*log(2)100000000 =   2657542475】26亿
3. 【O(n¹·²⁵))】    -------希尔排序：     【希尔排序】                    【 100000000^(1.25) =      10000000000 】100亿   ■ 第3组 出局■ 
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 100000000+50000000 =     15000】1.5亿


关于时间复杂度：N=1000000000 时 K=500000000 时 (对 1000000000 个数字中找到最大的 500000000 个)  N=10亿  K=5亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【1000000000*log(2)1000000000 =    29897352853】298亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 1000000000+500000000 =   1500000000】15亿


关于时间复杂度：N=1000000000 时 K=500000000 时 (对 1000000000 个数字中找到最大的 500000000 个)  N=1000亿  K=500亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【100000000000*log(2)100000000000 =    3654120904376】3.6万亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 100000000000+50000000000 =   150000000000】1500亿


关于时间复杂度：N=10000000000 时 K=5000000000 时 (对 10000000000 个数字中找到最大的 5000000000 个)  N=1万亿  K=5千亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【1000000000000 * log(2)1000000000000 = 39863137138648】39万亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 1000000000000+50000000000 =   1500000000000】1.5万亿



关于时间复杂度：N=10000000000 时 K=5000000000 时 (对 10000000000 个数字中找到最大的 5000000000 个)  N=1000万亿  K=500万亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【1000000000000000 * log(2)1000000000000000 = 4.982892142331e+16】4.9亿亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 1000000000000000+50000000000000 =   1500000000000】1500万亿


关于时间复杂度：N=10000000000 时 K=5000000000 时 (对 10000000000 个数字中找到最大的 5000000000 个)  N=1亿亿(Z)  K=5000万亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【10000000000000000 * log(2)10000000000000000 = 5.3150849518198e+17 】53 亿亿(Z)
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 10000000000000000+500000000000000 =   1500000000000】1.5 亿亿(Z)



关于时间复杂度：N=1000亿亿 时 K=500亿亿 时     N=1000亿亿  K=500亿亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【10000000000000000000 * log(2)10000000000000000000 =  6.311663380286e+20 】6.3万亿亿(Z)
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 10000000000000000000+500000000000000000 =   1500000000000000】1500 亿亿(Z)



关于时间复杂度：N=100万亿 时 K=50万亿 时    N=1000亿亿  K=500亿亿
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】   【10000000000000000000000 * log(2)10000000000000000000000 = 7.3082418087522e+23  】  7000万亿亿    亿亿(Z)
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】              【 10000000000000000000000+500000000000000000000 =   1500000000000000000】    150万亿亿(Z)



关于时间复杂度：N=1百亿亿亿 时 K=50亿亿亿 时  
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】 【100000000000000000000000000 * log(2)100000000000000000000000000 =   8.6370130467071e+27   】 8600亿亿亿  e+27=千亿亿亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】             【 100000000000000000000000000+50000000000000000000000000 =   1500000000000000000】   150亿亿亿



关于时间复杂度：N=1千亿亿亿 时 K=5百亿亿亿 时  
2. 【O(nlog2(n))】---线性对数阶排序: 【归并排序,快速排序,堆排序 】 【1000000000000000000000000000 * log(2)1000000000000000000000000000 =  8.9692058561959e+28   】 8.9万亿亿亿
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】             【 1000000000000000000000000000+500000000000000000000000000 =   1500000000000000000】   1500亿亿亿

 

关于时间复杂度：N=1万亿亿亿 时 K=0.5万亿亿亿 时  
2. 【O(nlog2(n))】线性对数阶排序: 【归并排序,快速排序,堆排序 】【 (log(10000000000000000000000000000)/log(2))*10000000000000000000000000000  =9.3013986656846e+29 】93万亿亿亿 ■第2组 胜出■ 
4. 【O(n+k)】------------- 低线性阶排序： 【计数排序,桶排序 】 【 10000000000000000000000000000+5000000000000000000000000000 = 1.5e+28  1500000000000000000】   1.5万亿亿亿  ▲第4组 出局▲ 

10^8   亿           100000000
10^9   十亿         1000000000
10^10  百亿         10000000000
10^11  千亿         100000000000
10^12  万亿         1000000000000
10^13  十万亿       10000000000000
10^14  百万亿       100000000000000
10^15  千万亿       1000000000000000
10^16  亿亿(Z)      10000000000000000 
10^17  十亿(Z)      100000000000000000
10^18  百亿亿       1000000000000000000
10^19  千亿亿       10000000000000000000
10^20  万亿亿       100000000000000000000
10^21  十万亿亿     1000000000000000000000
10^22  百万亿亿     10000000000000000000000
10^23  千万亿亿     100000000000000000000000
10^24  亿亿亿       1000000000000000000000000
10^25  十亿亿亿     10000000000000000000000000
10^26  百亿亿亿     100000000000000000000000000
10^27  千亿亿亿     1000000000000000000000000000
10^28  万亿亿亿     10000000000000000000000000000
10^29  十万亿亿亿   100000000000000000000000000000
10^30  百万亿亿亿   1000000000000000000000000000000
10^31  千万亿亿亿   10000000000000000000000000000000
10^32  亿亿亿亿     100000000000000000000000000000000
10^33  十亿亿亿亿   1000000000000000000000000000000000
10^34  百亿亿亿亿
10^35  千亿亿亿亿
10^36  万亿亿亿亿


N*log2(N) =( log(N) /log(2) ) * N
N = 10:     ( log(10) /log(2) ) * 10 =  33.2
N = 100:     ( log(100) /log(2) ) * 100 =  664
N = 1000:     ( log(1000) /log(2) ) * 1000 =  9965
N = 10000:     ( log(10000) /log(2) ) * 10000 =  132877
N = 100000:     ( log(100000) /log(2) ) * 100000 =  1660964
N = 1000000:     ( log(1000000) /log(2) ) * 1000000 =  19931568        N=1百万
N = 10000000:     ( log(10000000) /log(2) ) * 10000000 =  232534966          N=1千万
N = 100000000:     ( log(100000000) /log(2) ) * 100000000 =  2657542475           N=1亿
N = 1000000000:     ( log(1000000000) /log(2) ) * 1000000000 =  29897352853             N=10亿
N = 100000000000    ( log(100000000000) /log(2) ) * 100000000000 =  3654120904376             N=1000亿
N = 1000000000000    ( log(1000000000000) /log(2) ) * 1000000000000 =   39863137138648            N=1万亿
N = 1000000000000000   ( log(1000000000000000) /log(2) ) * 1000000000000000 =   4.982892142331e+16         N=1000万亿
N = 10000000000000000   ( log(10000000000000000) /log(2) ) * 10000000000000000 =  5.3150849518198e+17               N=1(Z 亿亿)
N = 10000000000000000000     ( log(10000000000000000000) /log(2) ) * 10000000000000000000   =  6.311663380286e+20         N=1000亿亿(Z)
N = 10000000000000000000000   ( log(10000000000000000000000) /log(2) ) * 10000000000000000000000   =  7.3082418087522e+23         N=100万亿亿(Z)
N = 1000000000000000000000000      ( log(1000000000000000000000000) /log(2) ) * 1000000000000000000000000   = 7.9726274277297e+25         N=1 亿亿亿
N = 100000000000000000000000000     ( log(100000000000000000000000000) /log(2) ) * 100000000000000000000000000   = 8.6370130467071e+27         N=1 百亿亿亿
N = 1000000000000000000000000000     ( log(1000000000000000000000000000) /log(2) ) * 1000000000000000000000000000   = 8.9692058561959e+28           N=1 千亿亿亿
N = 10000000000000000000000000000    ( log(10000000000000000000000000000) /log(2) ) * 10000000000000000000000000000   = 9.3013986656846e+29      N = 1万亿亿亿  【这里数值变小了】

10000000000000000000000000000^(1.25) = 1e+35 = 100亿亿亿亿
```


### 稳定性
<img src="/public/zimage/architect/01_sorttable.jpg">
```
假定在待排序的记录序列中，存在多个具有相同的关键字的记录，
若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，
且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。



稳定的排序算法：  冒泡排序、插入排序、归并排序和基数排序

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序

```




## 冒泡排序


## 冒泡排序简介
```
BubbleSort： 冒泡排序
简介:  是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。
冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。

```

### 冒泡排序算法步骤
```
1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3.针对所有的元素重复以上的步骤，除了最后一个。
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
```

### 冒泡排序动画演示
**图示1**
<img src="/public/zimage/architect/01_maopao.gif">
**图示2**
<img src="/public/zimage/architect/01_maopao1.gif">

### 冒泡排序最快情况
```
当输入的数据已经是正序时（都已经是正序了 每次对比都不需要移动元素）
   int order_arr[] = new int[]{1,2,3,4,5,6,7,8,9,10};
```

### 冒泡排序最慢情况
```
当输入的数据是反序时（每次对比都需要移动元素）
int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};

```

### 代码实现

##### Java 代码实现
```
package SortMethod;
import java.util.ArrayList;
import java.util.Arrays;
/**
 * 冒泡排序
 */
public class BubbleSort {
	
    public synchronized static int[] bubbleSort(int[] sourceArray)  {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 对位置移动的次数统计
        int changeNum = 0 ;
        for (int i = 1; i < arr.length; i++) {
            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
            boolean flag = true;

            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = false;
                    changeNum++;
                    System.out.println("第"+changeNum+"次交换位置");    
                }
            }
            if (flag) {
                break;
            }
        }
        System.out.println("总共交换"+changeNum+"次");    
        return arr;
    }
    
    public static void main(String[] args) {
    	System.out.println("=======================最快情况=======================");
        int order_arr[] = new int[]{1,2,3,4,5,6,7,8,9,10};
        int[] new_order_arr = BubbleSort.bubbleSort(order_arr);
        System.out.println(Arrays.toString(new_order_arr));
    	System.out.println("=======================最慢情况=======================");
        int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
        int[] newrevert_arr = BubbleSort.bubbleSort(revert_arr);
        System.out.println(Arrays.toString(newrevert_arr));

    }
}


/**
=======================最快情况=======================
总共交换0次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
第15次交换位置
第16次交换位置
第17次交换位置
第18次交换位置
第19次交换位置
第20次交换位置
第21次交换位置
第22次交换位置
第23次交换位置
第24次交换位置
第25次交换位置
第26次交换位置
第27次交换位置
第28次交换位置
第29次交换位置
第30次交换位置
第31次交换位置
第32次交换位置
第33次交换位置
第34次交换位置
第35次交换位置
第36次交换位置
第37次交换位置
第38次交换位置
第39次交换位置
第40次交换位置
第41次交换位置
第42次交换位置
第43次交换位置
第44次交换位置
第45次交换位置
总共交换45次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


**/

```


#### Python 代码实现
```
def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr


```



## 选择排序

## 选择排序简介
```
selectionSort :  选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。
```

### 选择排序算法步骤
```
1.首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2.再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3.重复第二步，直到所有元素均排序完毕。


```

### 选择排序动画演示
**演示一**
<img src="/public/zimage/architect/01_xuanze.gif">

**演示二**
<img src="/public/zimage/architect/01_xuanze1.gif">


### 选择排序最快情况
```
最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。 new int[]{1,2,3,4,5,6,7,8,9,10};

```
### 选择排序最慢情况
```
最坏情况下，即待排序记录初始状态是按第一条记录最小，之后的记录从小到大顺序排列，则需要移动记录的次数最多为3（n-1）次

new int[]{10,1,2,3,4,5,6,7,8,9};
```

### 代码实现

##### Java 代码实现

```
package SortMethod;
import java.util.ArrayList;
import java.util.Arrays;
/**
 * 选择排序
 */
public class SelectionSort {
	
        public synchronized static int[] selectionSort(int[] sourceArray)  {
        	
        	//  // 对 arr 进行拷贝，不改变参数内容
            int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

            // 对位置移动的次数统计
            int changeNum = 0 ;
            
            // 总共要经过 N-1 轮比较
            for (int i = 0; i < arr.length - 1; i++) {
                int min = i;

                // 每轮需要比较的次数 N-i
                for (int j = i + 1; j < arr.length; j++) {
                    if (arr[j] < arr[min]) {
                        // 记录目前能找到的最小值元素的下标
                        min = j;
                    }
                }

                // 将找到的最小值和i位置所在的值进行交换
                if (i != min) {
                    int tmp = arr[i];
                    arr[i] = arr[min];
                    arr[min] = tmp;
                    changeNum++;
                    System.out.println("第"+changeNum+"次交换位置");    
                }

            }
            System.out.println("总共交换"+changeNum+"次");    
            return arr;
        }
    
        
        
    public static void main(String[] args) {
    	System.out.println("=======================最快情况=======================");
        int order_arr[] = new int[]{10,};
        int[] new_order_arr = SelectionSort.selectionSort(order_arr);
        System.out.println(Arrays.toString(new_order_arr));
    	System.out.println("=======================最慢情况=======================");
        int revert_arr[] = new int[]{10,1,2,3,4,5,6,7,8,9};
        int[] newrevert_arr = SelectionSort.selectionSort(revert_arr);
        System.out.println(Arrays.toString(newrevert_arr));

    }
}

/*
=======================最快情况=======================
总共交换0次
[10]
=======================最慢情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
总共交换9次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
*/




```
## 插入排序

## 插入排序简介
```
insertionSort:  插入排序
插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

（插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂）
```

### 插入排序算法步骤
```
1.将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

2.从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。
 （如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）


```
### 插入排序动画演示
**演示一**
<img src="/public/zimage/architect/01_charu.gif">

**演示二**
<img src="/public/zimage/architect/01_charu1.gif">

### 插入排序最快情况
```

最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。 new int[]{1,2,3,4,5,6,7,8,9,10};

```
### 插入排序最慢情况
```
当输入的数据是反序时（每次对比都需要移动元素）
int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};

```

### 代码实现

#### Java 代码实现
```
package SortMethod;
import java.util.ArrayList;
import java.util.Arrays;
/**
 * 插入排序
 */
public class InsertSort {
	
	
    public synchronized static int[]  insertSort(int[] sourceArray)  {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 对位置移动的次数统计
        int changeNum = 0 ;
        
        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < arr.length; i++) {

            // 记录要插入的数据
            int tmp = arr[i];

            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0 && tmp < arr[j - 1]) {
                arr[j] = arr[j - 1];
                j--;
                changeNum++;
                System.out.println("第"+changeNum+"次交换位置");  
            }

            // 存在比其小的数，插入
            if (j != i) {
                arr[j] = tmp;
                changeNum++;
                System.out.println("第"+changeNum+"次交换位置");  
            }

        }
        System.out.println("总共交换"+changeNum+"次");    
        return arr;
    }
    
        
    public static void main(String[] args) {
    	System.out.println("=======================最快情况=======================");
    	int order_arr[] = new int[]{1,2,3,4,5,6,7,8,9,10};
        int[] new_order_arr = InsertSort.insertSort(order_arr);
        System.out.println(Arrays.toString(new_order_arr));
    	System.out.println("=======================最慢情况=======================");
        int revert_arr[] = new int[]{10,1,2,3,4,5,6,7,8,9};
        int[] newrevert_arr = InsertSort.insertSort(revert_arr);
        System.out.println(Arrays.toString(newrevert_arr));

    }
}

/*
=======================最快情况=======================
总共交换0次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
第15次交换位置
第16次交换位置
第17次交换位置
第18次交换位置
总共交换18次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
*/



```



## 希尔排序

## 希尔排序简介
```
shellSort : 希尔排序
希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是【 非稳定 】排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

```
### 希尔排序算法步骤
```
1.选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

2.按增量序列个数 k，对序列进行 k 趟排序；

3.每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。
  仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。


```
### 动画演示
<img src="/public/zimage/architect/01_xier.gif">

### 希尔排序最快情况
```
最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。 new int[]{1,2,3,4,5,6,7,8,9,10};

```
### 希尔排序最慢情况
```
当输入的数据是反序时（每次对比都需要移动元素）
int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};

```

### 代码实现
#### Java 代码实现
```
package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 希尔排序
 */
public class ShellSort {

	public synchronized static int[] shellSort(int[] sourceArray) {
		// 对 arr 进行拷贝，不改变参数内容
		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

		int gap = 1;
		// 对位置移动的次数统计
		int changeNum = 0;

		while (gap < arr.length) {
			gap = gap * 3 + 1;
		}

		while (gap > 0) {
			for (int i = gap; i < arr.length; i++) {
				int tmp = arr[i];
				int j = i - gap;
				while (j >= 0 && arr[j] > tmp) {
					arr[j + gap] = arr[j];
					j -= gap;
					changeNum++;
					System.out.println("第" + changeNum + "次交换位置");
				}
				arr[j + gap] = tmp;
			}
			gap = (int) Math.floor(gap / 3);
		}
		System.out.println("总共交换" + changeNum + "次");
		return arr;
	}

	public static void main(String[] args) {
		System.out.println("=======================最快情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = ShellSort.shellSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		System.out.println("=======================最慢情况=======================");
		int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
		int[] newrevert_arr = ShellSort.shellSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));

	}
}

/*
=======================最快情况=======================
总共交换0次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
总共交换13次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

*/


```



## 归并排序
## 归并排序简介
```
MergeSort：  归并排序
归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
自下而上的迭代；

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。
```
### 归并排序算法步骤
```
1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；

2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；

3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；

4.重复步骤 3 直到某一指针达到序列尾；

5.将另一序列剩下的所有元素直接复制到合并序列尾。

```
### 动画演示
**示例一**
<img src="/public/zimage/architect/01_guibing.gif">
**示例二**
<img src="/public/zimage/architect/01_guibing1.gif">
### 归并排序最快情况
```
最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。 new int[]{1,2,3,4,5,6,7,8,9,10};
```

### 归并排序最慢情况
```
当输入的数据是反序时（每次对比都需要移动元素）
int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};

```

### 代码实现
#### Java 代码实现
```
package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 归并排序
 */
public class MergeSort {

	static int changeNum = 0;
	public synchronized static  int[] mergeSort(int[] sourceArray)  {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

		changeNum++;
		System.out.println("第" + changeNum + "次迭代");
		
        if (arr.length < 2) {
            return arr;
        }
        int middle = (int) Math.floor(arr.length / 2);

        int[] left = Arrays.copyOfRange(arr, 0, middle);
        int[] right = Arrays.copyOfRange(arr, middle, arr.length);
        return merge(mergeSort(left), mergeSort(right));
    }
    


	public synchronized static  int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0;
        while (left.length > 0 && right.length > 0) {
            if (left[0] <= right[0]) {
                result[i++] = left[0];
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }

        while (left.length > 0) {
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        }

        while (right.length > 0) {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }

        return result;
    }
    

	public static void main(String[] args) {
		System.out.println("=======================最快情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = MergeSort.mergeSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		changeNum = 0 ; // 对迭代次数清零
		System.out.println("=======================最慢情况=======================");
		int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
		int[] newrevert_arr = MergeSort.mergeSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));
		changeNum = 0 ; // 对迭代次数清零
		System.out.println("=======================随意情况=======================");
		int rand_arr[] = new int[]{6,3,7,8,1,2,4,9,5,10};
		int[] newrRand_arr = MergeSort.mergeSort(rand_arr);
		System.out.println(Arrays.toString(newrRand_arr));
		changeNum = 0 ; // 对迭代次数清零
	}
}
/*
=======================最快情况=======================
第1次迭代
第2次迭代
第3次迭代
第4次迭代
第5次迭代
第6次迭代
第7次迭代
第8次迭代
第9次迭代
第10次迭代
第11次迭代
第12次迭代
第13次迭代
第14次迭代
第15次迭代
第16次迭代
第17次迭代
第18次迭代
第19次迭代
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次迭代
第2次迭代
第3次迭代
第4次迭代
第5次迭代
第6次迭代
第7次迭代
第8次迭代
第9次迭代
第10次迭代
第11次迭代
第12次迭代
第13次迭代
第14次迭代
第15次迭代
第16次迭代
第17次迭代
第18次迭代
第19次迭代
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================随意情况=======================
第1次迭代
第2次迭代
第3次迭代
第4次迭代
第5次迭代
第6次迭代
第7次迭代
第8次迭代
第9次迭代
第10次迭代
第11次迭代
第12次迭代
第13次迭代
第14次迭代
第15次迭代
第16次迭代
第17次迭代
第18次迭代
第19次迭代
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

*/

```



## 快速排序
## 快速排序简介

```
QuickSort : 快速排序
快速排序（Quicksort）是对冒泡排序的一种改进
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，
但这种状况并不常见。事实上，▲快速排序通常明显比其他 Ο(nlogn) 算法更快▲，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。


快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！
▲它是处理大数据最快的排序算法之一▲。

为什么: 
虽然 QuickSort 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好？

因为:
快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。
但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。

所以:
对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

```
### 快速排序算法步骤
```

1.从数列中挑出一个元素，称为 “基准”（pivot）;

2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。
虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。



```
### 动画演示
示例一
<img src="/public/zimage/architect/01_kuaisu.gif">
实例二
<img src="/public/zimage/architect/01_kuaisu1.gif">
### 快速排序最快情况
```
如果每次划分过程产生的区间大小都为n/2，则快速排序法运行就快得多了

```
### 快速排序最慢情况
```
快速排序算法的最坏情况运行时间为θ（n²），且最坏情况发生在每次划分过程产生的两个区间分别包含n-1个元素和1个元素的时候。

```
### 代码实现
#### Java 代码实现
```

package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 快速排序
 */
public class QuickSort {
	
	public synchronized static int[]  quickSort(int[] sourceArray) {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return quickSortInner(arr, 0, arr.length - 1);
    }

	public  static int[] quickSortInner(int[] arr, int left, int right) {
        if (left < right) {
            int partitionIndex = partition(arr, left, right);
            quickSortInner(arr, left, partitionIndex - 1);
            quickSortInner(arr, partitionIndex + 1, right);
        }
        return arr;
    }

	public  static  int partition(int[] arr, int left, int right) {
        // 设定基准值（pivot）
        int pivot = left;
        int index = pivot + 1;
        for (int i = index; i <= right; i++) {
            if (arr[i] < arr[pivot]) {
                swap(arr, i, index);
                index++;
            }
        }
        swap(arr, pivot, index - 1);
        return index - 1;
    }
	static int changeNum = 0;
	public  static  void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
		changeNum++;
		System.out.println("第" + changeNum + "次交换位置");
    }
    

	public static void main(String[] args) {
		System.out.println("=======================最快情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = QuickSort.quickSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		changeNum=0; 
		System.out.println("=======================最慢情况=======================");
		int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
		int[] newrevert_arr = QuickSort.quickSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));

	}
}

/*

=======================最快情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
第15次交换位置
第16次交换位置
第17次交换位置
第18次交换位置
第19次交换位置
第20次交换位置
第21次交换位置
第22次交换位置
第23次交换位置
第24次交换位置
第25次交换位置
第26次交换位置
第27次交换位置
第28次交换位置
第29次交换位置
第30次交换位置
第31次交换位置
第32次交换位置
第33次交换位置
第34次交换位置
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


*/

```



## 堆排序

## 堆排序简介
```
HeapSort : 堆排序
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。
堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：
即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。

分为两种方法：
1.  大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2.  小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

堆排序的平均时间复杂度为 Ο(nlogn)。
```

### 堆排序算法步骤
```
1.创建一个堆 H[0……n-1]；
2.把堆首（最大值）和堆尾互换；
3.把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
4.重复步骤 2，直到堆的尺寸为 1。

```

### 动画演示
**示例一**
<img src="/public/zimage/architect/01_dui.gif">

**示例二**
<img src="/public/zimage/architect/01_dui1.gif">
### 堆排序最快情况
```
如果初始数组是非降序排序，那么就不需要调堆，直接就满足堆的定义，此为最好情况，运行时间为Θ(1)；

```
### 堆排序最慢情况
```
如果初始数组是如图1.5，只有A[0] = 1不满足堆的定义，经过与子节点的比较调整到图1.6，
但是图1.6仍然不满足堆的定义，所以要递归调整，一直到满足堆的定义或者到堆底为止。
如果递归调堆到堆底才结束，那么是最坏情况，运行时间为O(h) (h为需要调整的节点的高度，堆底高度为0，堆顶高度为floor(logn) )。

总运行时间T(n) = O(nlogn) + O(n) = O(nlogn)。对于堆排序的最好情况与最坏情况的运行时间，
因为最坏与最好的输入都只是影响建堆的运行时间O(1)或者O(n)，
而在总体时间中占重要比例的是循环调堆的过程，即O(nlogn) + O(1) =O(nlogn) + O(n) = O(nlogn)。
因此最好或者最坏情况下，堆排序的运行时间都是O(nlogn)

```
<img src="/public/zimage/architect/01_dui2.jpg">
### 代码实现
#### Java 代码实现

```
package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 堆排序
 */
public class HeapSort {
	
	

	public synchronized static int[]  heapSort(int[] sourceArray) {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int len = arr.length;

        buildMaxHeap(arr, len);

        for (int i = len - 1; i > 0; i--) {
            swap(arr, 0, i);
            len--;
            heapify(arr, 0, len);
        }
        return arr;
    }

	public static void buildMaxHeap(int[] arr, int len) {
        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {
            heapify(arr, i, len);
        }
    }

	public static  void heapify(int[] arr, int i, int len) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int largest = i;

        if (left < len && arr[left] > arr[largest]) {
            largest = left;
        }

        if (right < len && arr[right] > arr[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, largest, len);
        }
    }

	public static  void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
		changeNum++;
		System.out.println("第" + changeNum + "次交换位置");
    }

    
	static int changeNum = 0;
	public static void main(String[] args) {
		System.out.println("=======================正序堆排序情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = HeapSort.heapSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		changeNum =0 ;
		System.out.println("=======================逆序堆排序情况=======================");
		int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
		int[] newrevert_arr = HeapSort.heapSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));

	}
}

/*
=======================正序堆排序情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
第15次交换位置
第16次交换位置
第17次交换位置
第18次交换位置
第19次交换位置
第20次交换位置
第21次交换位置
第22次交换位置
第23次交换位置
第24次交换位置
第25次交换位置
第26次交换位置
第27次交换位置
第28次交换位置
第29次交换位置
第30次交换位置
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================逆序堆排序情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
第15次交换位置
第16次交换位置
第17次交换位置
第18次交换位置
第19次交换位置
第20次交换位置
第21次交换位置
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 */


```

## 计数排序
## 计数排序简介
```
CountingSort ： 计数排序
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

```
### 计数排序算法步骤
### 动画演示
**示意一**
<img src="/public/zimage/architect/01_jishu1.gif">

**示意二**
<img src="/public/zimage/architect/01_jishu11.gif">
### 计数排序最快情况
### 计数排序最慢情况
### 代码实现
#### Java 代码实现
```
package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 计数排序
 */
public class CountingSort {

	public synchronized static int[]  countingSort(int[] sourceArray)  {
	        // 对 arr 进行拷贝，不改变参数内容
	        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

	        int maxValue = getMaxValue(arr);

	        return countingSortInner(arr, maxValue);
	    }

	public  static  int[] countingSortInner(int[] arr, int maxValue) {
	        int bucketLen = maxValue + 1;
	        int[] bucket = new int[bucketLen];

	        for (int value : arr) {
	            bucket[value]++;
	        }

	        int sortedIndex = 0;
	        for (int j = 0; j < bucketLen; j++) {
	            while (bucket[j] > 0) {
	                arr[sortedIndex++] = j;
	                bucket[j]--;
					changeNum++;
					System.out.println("第" + changeNum + "次交换位置");
	            }
	        }
	        return arr;
	    }
     static int changeNum = 0;  // 交换次数
	public  static  int getMaxValue(int[] arr) {
	        int maxValue = arr[0];
	        for (int value : arr) {
	            if (maxValue < value) {
	                maxValue = value;
	            }
	        }
	        return maxValue;
	    }
	    
	public static void main(String[] args) {
		System.out.println("=======================最快情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = CountingSort.countingSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		changeNum = 0 ;
		System.out.println("=======================最慢情况=======================");
		int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
		int[] newrevert_arr = CountingSort.countingSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));

	}
}

/*
=======================最快情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

*/




```



## 桶排序
## 桶排序简介
```
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
为了使桶排序更加高效，我们需要做到这两点：

1. 在额外空间充足的情况下，尽量增大桶的数量
2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。



特性说明：
1. 桶排序的时间复杂度通常是O(N+N*logM)，其中，N表示桶的个数，M表示桶内元素的个数
  （这里，M取的是一个大概的平均数，这也说明，为何桶内的元素尽量不要出现有的很多，有的很少这种分布不均的事情，分布不均的话，算法的性能优势就不能最大发挥）。

2. 桶排序是稳定的（是可以做到平衡排序的）。

3. 桶排序，在内存方面消耗是比较大的，可以说其时间性能优势是由牺牲空间换来的。
```
### 桶排序算法步骤
```
1. 根据数据类型，定义数据映射函数f(x)

2. 对数据进行分别规划进入桶内

3. 对桶做基于序号的排序

4. 对每个桶内的数据进行排序（快排或者其他排序算法）

5. 将排序后的数据映射到原始输入数组中，作为输出

```
### 动画演示
<img src="/public/zimage/architect/01_tong.gif">

### 桶排序最快情况
```
当输入的数据可以均匀的分配到每一个桶中。

```
### 桶排序最慢情况
```
当输入的数据被分配到了同一个桶中。

```
### 代码实现
#### Java 代码实现
```
package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 桶排序
 */
public class BucketSort {

	public static final InsertSort insertSort = new InsertSort();

	public synchronized static int[] bucketSort(int[] sourceArray) {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return bucketSortInner(arr, 5);
    }

	public static int[] bucketSortInner(int[] arr, int bucketSize) {
        if (arr.length == 0) {
            return arr;
        }

        int minValue = arr[0];
        int maxValue = arr[0];
        for (int value : arr) {
            if (value < minValue) {
                minValue = value;
            } else if (value > maxValue) {
                maxValue = value;
            }
        }

        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;
        int[][] buckets = new int[bucketCount][0];

        // 利用映射函数将数据分配到各个桶中
        for (int i = 0; i < arr.length; i++) {
            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);
            buckets[index] = arrAppend(buckets[index], arr[i]);
        }

        int arrIndex = 0;
        for (int[] bucket : buckets) {
            if (bucket.length <= 0) {
                continue;
            }
            
			changeNum++;
			System.out.println("第" + changeNum + "次执行插入排序方法");
            // 对每个桶进行排序，这里使用了插入排序
            bucket = insertSort.insertSort(bucket);   // 这里引用了插入排序的类 insertSort

            for (int value : bucket) {
                arr[arrIndex++] = value;
            }
        }

        return arr;
    }
   static int changeNum = 0 ;

    /**
     * 自动扩容，并保存数据
     *
     * @param arr
     * @param value
     */
	public static int[] arrAppend(int[] arr, int value) {
        arr = Arrays.copyOf(arr, arr.length + 1);
        arr[arr.length - 1] = value;
        return arr;
    }



	public static void main(String[] args) {
		System.out.println("=======================最快情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = BucketSort.bucketSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		changeNum=0;
		System.out.println("=======================最慢情况=======================");
		int revert_arr[] = new int[]{10,9,8,7,6,5,4,3,2,1};
		int[] newrevert_arr = BucketSort.bucketSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));

	}
}


/*
 =======================最快情况=======================
第1次执行插入排序方法
总共交换0次
第2次执行插入排序方法
总共交换0次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
第1次执行插入排序方法
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
总共交换14次
第2次执行插入排序方法
第1次交换位置
第2次交换位置
第3次交换位置
第4次交换位置
第5次交换位置
第6次交换位置
第7次交换位置
第8次交换位置
第9次交换位置
第10次交换位置
第11次交换位置
第12次交换位置
第13次交换位置
第14次交换位置
总共交换14次
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 */



```
## 基数排序
## 基数排序简介
```
RadixSort  : 基数排序
基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。
由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

```

```
基数排序 vs 计数排序 vs 桶排序


1. 计数排序 和桶排序 有一种方法， 基数排序有两种方法：

2.这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
  基数排序：根据键值的每位数字来分配桶；
  计数排序：每个桶只存储单一键值；
  桶排序：每个桶存储一定范围的数值；
```
### 基数排序算法步骤
```
1.初始化：构造一个10*n的二维数组，一个长度为n的数组用于存储每次位排序时每个桶子里有多少个元素。

2.循环操作：从低位开始（我们采用LSD的方式），将所有元素对应该位的数字存到相应的桶子里去（对应二维数组的那一列）
然后将所有桶子里的元素按照桶子标号从小到大取出，对于同一个桶子里的元素，先放进去的先取出，后放进去的后取出（保证排序稳定性）。
这样原数组就按该位排序完毕了，继续下一位操作，直到最高位排序完成。

```
### 动画演示
**演示一**
<img src="/public/zimage/architect/01_jishu2.gif">

**演示二**
<img src="/public/zimage/architect/01_jishu22.gif">
### 基数排序最快情况
```

```
### 基数排序最慢情况

```

```
### 代码实现
#### Java 代码实现
```
package SortMethod;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * 基数排序
 */
public class RadixSort {

	public synchronized static int[] radixSort(int[] sourceArray) {
		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

		int maxDigit = getMaxDigit(arr);
		return radixSortInner(arr, maxDigit);
	}

	/**
	 * 获取最高位数
	 */
	public static int getMaxDigit(int[] arr) {
		int maxValue = getMaxValue(arr);
		return getNumLenght(maxValue);
	}

	public static int getMaxValue(int[] arr) {
		int maxValue = arr[0];
		for (int value : arr) {
			if (maxValue < value) {
				maxValue = value;
			}
		}
		return maxValue;
	}

	public static int getNumLenght(long num) {
		if (num == 0) {
			return 1;
		}
		int lenght = 0;
		for (long temp = num; temp != 0; temp /= 10) {
			lenght++;
		}
		return lenght;
	}

	public static int[] radixSortInner(int[] arr, int maxDigit) {
		int mod = 10;
		int dev = 1;

		for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
			// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)
			int[][] counter = new int[mod * 2][0];

			for (int j = 0; j < arr.length; j++) {
				int bucket = ((arr[j] % mod) / dev) + mod;
				counter[bucket] = arrayAppend(counter[bucket], arr[j]);
			}

			int pos = 0;
			for (int[] bucket : counter) {
				for (int value : bucket) {
					arr[pos++] = value;
				}
			}
		}

		return arr;
	}

	/**
	 * 自动扩容，并保存数据
	 *
	 * @param arr
	 * @param value
	 */
	public static int[] arrayAppend(int[] arr, int value) {
		arr = Arrays.copyOf(arr, arr.length + 1);
		arr[arr.length - 1] = value;
		return arr;
	}

	public static void main(String[] args) {
		System.out.println("=======================最快情况=======================");
		int order_arr[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		int[] new_order_arr = RadixSort.radixSort(order_arr);
		System.out.println(Arrays.toString(new_order_arr));
		System.out.println("=======================最慢情况=======================");
		int revert_arr[] = new int[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
		int[] newrevert_arr = RadixSort.radixSort(revert_arr);
		System.out.println(Arrays.toString(newrevert_arr));

	}
}

/*
=======================最快情况=======================
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=======================最慢情况=======================
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

*/


```
