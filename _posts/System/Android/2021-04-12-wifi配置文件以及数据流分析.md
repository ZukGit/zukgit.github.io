---
layout: post
title: wifi配置文件以及数据流分析
category: 系统
tags: Wifi AOSP
keywords: 
typora-root-url: ..\..\..\
typora-copy-images-to: ..\..\..\public\zimage
---

## 简介
 * TOC
 {:toc}
## /data/system/users/0/settings_system.xml

```
adb pull /data/system/users/0/settings_system.xml
adb push settings_system.xml /data/system/users/0/
```

```
<?xml version='1.0' encoding='UTF-8' standalone='yes' ?>
<settings version="178">
  <setting id="129" name="volume_music_speaker" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="20" name="notification_light_pulse" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="43" name="notification_sound" value="content://media/internal/audio/media/58" package="com.android.providers.media" />
  <setting id="4" name="volume_alarm" value="6" package="android" defaultValue="6" defaultSysSet="true" />
  <setting id="0" name="volume_music" value="5" package="android" defaultValue="5" defaultSysSet="true" />
  <setting id="3" name="volume_voice" value="4" package="android" defaultValue="4" defaultSysSet="true" />
  <setting id="39" name="ringtone" value="content://media/internal/audio/media/33" package="com.android.providers.media" />
  <setting id="38" name="ringtone_2_set" value="1" package="com.android.providers.media" />
  <setting id="13" name="hearing_aid" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="1" name="volume_ring" value="5" package="android" defaultValue="5" defaultSysSet="true" />
  <setting id="17" name="screen_brightness_mode" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="42" name="alarm_alert_set" value="1" package="com.android.providers.media" />
  <setting id="8" name="mute_streams_affected" value="47" package="android" defaultValue="47" defaultSysSet="true" />
  <setting id="14" name="tty_mode" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="16" name="screen_brightness_for_vr" value="86" package="android" defaultValue="86" defaultSysSet="true" />
  <setting id="40" name="ringtone_set" value="1" package="com.android.providers.media" />
  <setting id="33" name="font_scale" value="1.0" package="android" defaultValue="1.0" defaultSysSet="true" />
  <setting id="10" name="dim_screen" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="44" name="notification_sound_set" value="1" package="com.android.providers.media" />
  <setting id="6" name="volume_bluetooth_sco" value="7" package="android" defaultValue="7" defaultSysSet="true" />
  <setting id="23" name="lockscreen_sounds_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="108" name="user_rotation" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="109" name="accelerometer_rotation" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="45" name="screen_off_timeout" value="30000" package="com.google.android.setupwizard" defaultValue="30000" defaultSysSet="true" />
  <setting id="9" name="vibrate_when_ringing" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="30" name="hide_rotation_lock_toggle_for_accessibility" value="0" package="com.android.systemui" defaultValue="0" defaultSysSet="true" />
  <setting id="41" name="alarm_alert" value="content://media/internal/audio/media/50" package="com.android.providers.media" />
  <setting id="24" name="pointer_speed" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="26" name="mode_ringer_streams_affected" value="422" package="android" defaultValue="422" defaultSysSet="true" />
  <setting id="5" name="volume_notification" value="5" package="android" defaultValue="5" defaultSysSet="true" />
  <setting id="12" name="dtmf_tone_type" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="21" name="dtmf_tone" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="36" name="system_locales" value="zh-Hans-CN" package="android" defaultValue="zh-Hans-CN" defaultSysSet="true" />
  <setting id="2" name="volume_system" value="7" package="android" defaultValue="7" defaultSysSet="true" />
  <setting id="25" name="status_bar_show_battery_percent" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="37" name="ringtone_2" value="content://media/internal/audio/media/33" package="com.android.providers.media" />
  <setting id="22" name="sound_effects_enabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="161" name="screen_brightness" value="62" package="android" defaultValue="62" defaultSysSet="true" />
  <setting id="19" name="haptic_feedback_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
</settings>

```

## /data/system/users/0/settings_secure.xml


```
adb pull /data/system/users/0/settings_secure.xml
adb push settings_secure.xml /data/system/users/0/
```


```
<?xml version='1.0' encoding='UTF-8' standalone='yes' ?>
<settings version="178">
  <setting id="23" name="lock_screen_show_notifications" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="33" name="unknown_sources_default_reversed" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="53" name="sysui_volume_up_silent" package="com.android.systemui" />
  <setting id="29" name="camera_double_tap_power_gesture_disabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="94" name="allowed_geolocation_origins" value="http://www.google.com http://www.google.co.uk" package="com.google.android.setupwizard" defaultValue="http://www.google.com http://www.google.co.uk" defaultSysSet="true" />
  <setting id="20" name="immersive_mode_confirmations" value="" package="android" defaultValue="" defaultSysSet="true" />
  <setting id="79" name="default_input_method" value="com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME" package="android" defaultValue="com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME" defaultSysSet="true" />
  <setting id="25" name="sleep_timeout" value="-1" package="android" defaultValue="-1" defaultSysSet="true" />
  <setting id="93" name="location_providers_allowed" value="gps,network" package="com.google.android.gms" defaultValue="" defaultSysSet="true" />
  <setting id="83" name="doze_enabled" value="2" package="com.rockrola.rockdisplay" />
  <setting id="24" name="lock_screen_allow_private_notifications" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="27" name="double_tap_to_wake" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="10" name="speak_password" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="22" name="wake_gesture_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="14" name="screensaver_activate_on_sleep" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="36" name="volume_hush_gesture" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="57" name="sysui_qs_fancy_anim" package="com.android.systemui" />
  <setting id="80" name="backup_enabled" package="android" />
  <setting id="64" name="sysui_keyguard_right" package="com.android.systemui" />
  <setting id="62" name="sysui_qs_move_whole_rows" package="com.android.systemui" />
  <setting id="96" name="user_setup_complete" value="1" package="com.google.android.setupwizard" defaultValue="1" defaultSysSet="true" />
  <setting id="63" name="sysui_volume_down_silent" package="com.android.systemui" />
  <setting id="82" name="nfc_payment_default_component" value="com.google.android.gms/com.google.android.gms.tapandpay.hce.service.TpHceService" package="com.android.nfc" defaultValue="com.google.android.gms/com.google.android.gms.tapandpay.hce.service.TpHceService" defaultSysSet="true" />
  <setting id="38" name="manual_ringer_toggle_count" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="58" name="sysui_do_not_disturb" package="com.android.systemui" />
  <setting id="51" name="trust_agents_initialized" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="11" name="lockscreen.disabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="49" name="enabled_notification_assistant" value="com.google.android.ext.services/android.ext.services.notification.Assistant" package="android" defaultValue="com.google.android.ext.services/android.ext.services.notification.Assistant" defaultSysSet="true" />
  <setting id="39" name="lock_screen_owner_info_enabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="54" name="accessibility_display_inversion_enabled" package="com.android.systemui" />
  <setting id="73" name="selected_spell_checker_subtype" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="8" name="long_press_timeout" value="400" package="android" defaultValue="400" defaultSysSet="true" />
  <setting id="44" name="sysui_tuner_version" value="4" package="com.android.systemui" defaultValue="4" defaultSysSet="true" />
  <setting id="68" name="sysui_nav_bar_left" package="com.android.systemui" />
  <setting id="99" name="com.google.android.gms.backup/dogfood_secondary_key" package="com.google.android.gms" />
  <setting id="43" name="voice_recognition_service" value="com.google.android.googlequicksearchbox/com.google.android.voicesearch.serviceapi.GoogleRecognitionService" package="android" defaultValue="com.google.android.googlequicksearchbox/com.google.android.voicesearch.serviceapi.GoogleRecognitionService" defaultSysSet="true" />
  <setting id="35" name="notification_badging" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="15" name="screensaver_components" value="com.google.android.deskclock/com.android.deskclock.Screensaver" package="android" defaultValue="com.google.android.deskclock/com.android.deskclock.Screensaver" defaultSysSet="true" />
  <setting id="42" name="voice_interaction_service" value="com.google.android.googlequicksearchbox/com.google.android.voiceinteraction.GsaVoiceInteractionService" package="android" defaultValue="com.google.android.googlequicksearchbox/com.google.android.voiceinteraction.GsaVoiceInteractionService" defaultSysSet="true" />
  <setting id="18" name="accessibility_display_magnification_scale" value="2.0" package="android" defaultValue="2.0" defaultSysSet="true" />
  <setting id="98" name="qs_auto_tiles" value="hotspot" package="com.android.systemui" defaultValue="hotspot" defaultSysSet="true" />
  <setting id="37" name="hush_gesture_used" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="13" name="screensaver_activate_on_dock" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="3" name="backup_transport" value="com.google.android.gms/.backup.BackupTransportService" package="android" defaultValue="com.google.android.gms/.backup.BackupTransportService" defaultSysSet="true" />
  <setting id="87" name="input_methods_subtype_history" value="com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME;-1" package="android" defaultValue="com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME;-1" defaultSysSet="true" />
  <setting id="1" name="mock_location" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="90" name="systemui.google.opa_enabled" value="0" package="com.android.systemui" defaultValue="0" defaultSysSet="true" />
  <setting id="52" name="bluetooth_name" value="IxxI" package="android" defaultValue="IxxI" defaultSysSet="true" />
  <setting id="34" name="autofill_service" value="com.google.android.gms/.autofill.service.AutofillService" package="android" defaultValue="com.google.android.gms/.autofill.service.AutofillService" defaultSysSet="true" />
  <setting id="65" name="sysui_keyguard_left" package="com.android.systemui" />
  <setting id="88" name="sync_parent_sounds" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="70" name="sysui_nav_bar" package="com.android.systemui" />
  <setting id="12" name="screensaver_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="89" name="snoozed_schedule_condition_provider" value="" package="android" defaultValue="" defaultSysSet="true" />
  <setting id="4" name="mount_play_not_snd" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="7" name="mount_ums_notify_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="59" name="overview_nav_bar_gesture" package="com.android.systemui" />
  <setting id="67" name="icon_blacklist" package="com.android.systemui" />
  <setting id="26" name="android_id" value="c179193d5ff11435" package="android" defaultValue="c179193d5ff11435" defaultSysSet="true" />
  <setting id="9" name="touch_exploration_enabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="97" name="sysui_qs_tiles" value="wifi,bt,dnd,flashlight,rotation,battery,cell,airplane,night,custom(com.rockrola.ccc.ota/.env.SystemUpdateQSTile),cast,hotspot" package="com.android.systemui" defaultValue="wifi,bt,dnd,flashlight,rotation,battery,cell,airplane,night,custom(com.rockrola.ccc.ota/.env.SystemUpdateQSTile),cast,hotspot" defaultSysSet="true" />
  <setting id="61" name="sysui_qqs_count" package="com.android.systemui" />
  <setting id="48" name="enabled_notification_listeners" value="com.rockrola.rockdisplay/com.rockrola.rockdisplay.notification.DisplayNotifListenerService:com.rockrola.launcher3/com.android.launcher3.notification.NotificationListener:com.google.android.apps.restore/com.google.android.apps.pixelmigrate.component.NotificationConsolidatorService" package="android" defaultValue="com.rockrola.rockdisplay/com.rockrola.rockdisplay.notification.DisplayNotifListenerService:com.rockrola.launcher3/com.android.launcher3.notification.NotificationListener:com.google.android.apps.restore/com.google.android.apps.pixelmigrate.component.NotificationConsolidatorService" defaultSysSet="true" />
  <setting id="69" name="qs_show_brightness" package="com.android.systemui" />
  <setting id="40" name="carrier_apps_handled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="50" name="enabled_notification_policy_access_packages" value="com.rockrola.camera2:com.android.camera2:com.google.android.apps.wellbeing:com.rockrola.arselfie:com.rockrola.cameraone" package="android" defaultValue="com.rockrola.camera2:com.android.camera2:com.google.android.apps.wellbeing:com.rockrola.arselfie:com.rockrola.cameraone" defaultSysSet="true" />
  <setting id="75" name="selected_input_method_subtype" value="-1" package="android" defaultValue="-1" defaultSysSet="true" />
  <setting id="6" name="mount_ums_prompt" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="71" name="sysui_nav_bar_right" package="com.android.systemui" />
  <setting id="72" name="selected_spell_checker" value="com.google.android.inputmethod.latin/com.android.inputmethod.latin.spellcheck.AndroidSpellCheckerService" package="android" defaultValue="com.google.android.inputmethod.latin/com.android.inputmethod.latin.spellcheck.AndroidSpellCheckerService" defaultSysSet="true" />
  <setting id="95" name="last_setup_shown" value="eclair_1" package="com.google.android.setupwizard" defaultValue="eclair_1" defaultSysSet="true" />
  <setting id="16" name="screensaver_default_component" value="com.google.android.deskclock/com.android.deskclock.Screensaver" package="android" defaultValue="com.google.android.deskclock/com.android.deskclock.Screensaver" defaultSysSet="true" />
  <setting id="5" name="mount_ums_autostart" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="85" name="sms_default_application" value="com.google.android.apps.messaging" package="com.android.phone" defaultValue="com.google.android.apps.messaging" defaultSysSet="true" />
  <setting id="66" name="sysui_rounded_content_padding" package="com.android.systemui" />
  <setting id="32" name="install_non_market_apps" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="81" name="bluetooth_address" value="C0:8C:71:AC:DA:32" package="android" defaultValue="C0:8C:71:AC:DA:32" defaultSysSet="true" />
  <setting id="56" name="keyguard_slice_uri" package="com.android.systemui" />
  <setting id="28" name="show_ime_with_hard_keyboard" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="41" name="accessibility_enabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="30" name="multi_press_timeout" value="300" package="android" defaultValue="300" defaultSysSet="true" />
  <setting id="17" name="accessibility_display_magnification_enabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="55" name="sysui_rounded_size" package="com.android.systemui" />
  <setting id="47" name="user_setup_personalization_state" value="0" package="com.google.android.setupwizard" defaultValue="0" defaultSysSet="true" />
  <setting id="60" name="clock_seconds" package="com.android.systemui" />
  <setting id="78" name="enabled_input_methods" value="com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME:com.google.android.googlequicksearchbox/com.google.android.voicesearch.ime.VoiceInputMethodService" package="android" defaultValue="com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME:com.google.android.googlequicksearchbox/com.google.android.voicesearch.ime.VoiceInputMethodService" defaultSysSet="true" />
</settings>


```
## /data/system/users/0/settings_global.xml

```
adb pull /data/system/users/0/settings_global.xml
adb push settings_global.xml /data/system/users/0/
```

```
<?xml version='1.0' encoding='UTF-8' standalone='yes' ?>
<settings version="178">
  <setting id="43" name="low_battery_sound_timeout" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="35" name="car_undock_sound" value="/system/media/audio/ui/Undock.ogg" package="android" defaultValue="/system/media/audio/ui/Undock.ogg" defaultSysSet="true" />
  <setting id="117" name="Phenotype_flags" value="" package="com.google.android.gms" />
  <setting id="10" name="window_animation_scale" value="1.0" package="android" defaultValue="1.0" defaultSysSet="true" />
  <setting id="57" name="show_zen_settings_suggestion" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="9" name="mode_ringer" value="2" package="android" defaultValue="2" defaultSysSet="true" />
  <setting id="39" name="default_install_location" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="24" name="wifi_display_on" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="46" name="device_name" value="IxxI" package="android" defaultValue="IxxI" defaultSysSet="true" />
  <setting id="14" name="wifi_networks_available_notification_on" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="114" name="zen_settings_updated" value="1" package="com.android.settings" defaultValue="1" defaultSysSet="true" />
  <setting id="31" name="dock_sounds_enabled_when_accessbility" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="119" name="bluetooth_on" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="20" name="mobile_data" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="124" name="network_watchlist_last_report_time" value="1553529600000" package="android" defaultValue="1553529600000" defaultSysSet="true" />
  <setting id="47" name="database_creation_buildid" value="PPF29.92" package="android" defaultValue="PPF29.92" defaultSysSet="true" />
  <setting id="40" name="emergency_tone" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="55" name="max_sound_trigger_detection_service_ops_per_day" value="1000" package="android" defaultValue="1000" defaultSysSet="true" />
  <setting id="48" name="add_users_when_locked" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="37" name="dock_audio_media_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="88" name="ble_scan_always_enabled" value="1" package="com.google.android.gms" />
  <setting id="96" name="dropbox_max_files" value="1000" package="com.rockrola.ccc.devicemanagement" />
  <setting id="75" name="adb_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="27" name="trusted_sound" value="/system/media/audio/ui/Trusted.ogg" package="android" defaultValue="/system/media/audio/ui/Trusted.ogg" defaultSysSet="true" />
  <setting id="26" name="unlock_sound" value="/system/media/audio/ui/Unlock.ogg" package="android" defaultValue="/system/media/audio/ui/Unlock.ogg" defaultSysSet="true" />
  <setting id="63" name="hs20_saved_state" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="2" name="airplane_mode_radios" value="cell,bluetooth,wifi,nfc,wimax" package="android" defaultValue="cell,bluetooth,wifi,nfc,wimax" defaultSysSet="true" />
  <setting id="23" name="wifi_max_dhcp_retry_count" value="9" package="android" defaultValue="9" defaultSysSet="true" />
  <setting id="3" name="airplane_mode_toggleable_radios" value="bluetooth,wifi,nfc" package="android" defaultValue="bluetooth,wifi,nfc" defaultSysSet="true" />
  <setting id="16" name="sys_storage_full_threshold_bytes" value="2097152" package="android" defaultValue="2097152" defaultSysSet="true" />
  <setting id="45" name="heads_up_notifications_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="74" name="low_power" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="60" name="charging_vibration_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="65" name="zen_mode_ringer_level" value="2" package="android" defaultValue="2" defaultSysSet="true" />
  <setting id="42" name="preferred_network_mode" value="10" package="android" defaultValue="10" defaultSysSet="true" />
  <setting id="49" name="bluetooth_disabled_profiles" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="33" name="desk_undock_sound" value="/system/media/audio/ui/Undock.ogg" package="android" defaultValue="/system/media/audio/ui/Undock.ogg" defaultSysSet="true" />
  <setting id="54" name="zen_duration" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="52" name="mobile_data_always_on" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="67" name="webview_provider" value="com.android.chrome" package="android" defaultValue="com.android.chrome" defaultSysSet="true" />
  <setting id="8" name="wifi_sleep_policy" value="2" package="android" defaultValue="2" defaultSysSet="true" />
  <setting id="84" name="device_provisioning_mobile_data" value="0" package="com.google.android.setupwizard" defaultValue="0" defaultSysSet="true" />
  <setting id="30" name="dock_sounds_enabled" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="87" name="wifi_scan_always_enabled" value="1" package="com.google.android.gms" defaultValue="0" defaultSysSet="true" />
  <setting id="113" name="network_recommendations_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="34" name="car_dock_sound" value="/system/media/audio/ui/Dock.ogg" package="android" defaultValue="/system/media/audio/ui/Dock.ogg" defaultSysSet="true" />
  <setting id="56" name="sound_trigger_detection_service_op_timeout" value="15000" package="android" defaultValue="15000" defaultSysSet="true" />
  <setting id="28" name="power_sounds_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="7" name="stay_on_while_plugged_in" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="94" name="package_verifier_user_consent" value="1" package="com.android.vending" />
  <setting id="123" name="zen_mode_config_etag" value="-989698968" package="android" defaultValue="-989698968" defaultSysSet="true" />
  <setting id="38" name="set_install_location" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="64" name="zen_mode" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="11" name="transition_animation_scale" value="1.0" package="android" defaultValue="1.0" defaultSysSet="true" />
  <setting id="12" name="package_verifier_enable" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="89" name="network_recommendations_package" value="com.google.android.gms" package="android" defaultValue="com.google.android.gms" defaultSysSet="true" />
  <setting id="1" name="theater_mode_on" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="18" name="cdma_cell_broadcast_sms" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="0" name="airplane_mode_on" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="59" name="zen_settings_suggestion_viewed" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="51" name="default_restrict_background_data" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="29" name="low_battery_sound" value="/system/media/audio/ui/LowBattery.ogg" package="android" defaultValue="/system/media/audio/ui/LowBattery.ogg" defaultSysSet="true" />
  <setting id="21" name="netstats_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="95" name="dropbox_quota_kb" value="5242880" package="com.rockrola.ccc.devicemanagement" />
  <setting id="50" name="wifi_wakeup_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="77" name="subscription_mode" value="0" package="com.android.phone" defaultValue="0" defaultSysSet="true" />
  <setting id="86" name="assisted_gps_enabled" value="1" package="com.google.android.gsf" defaultValue="1" defaultSysSet="true" />
  <setting id="25" name="lock_sound" value="/system/media/audio/ui/Lock.ogg" package="android" defaultValue="/system/media/audio/ui/Lock.ogg" defaultSysSet="true" />
  <setting id="6" name="auto_time_zone" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="120" name="wifi_on" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="112" name="wifi_country_code" value="cn" package="android" defaultValue="cn" defaultSysSet="true" />
  <setting id="53" name="wireless_charging_started_sound" value="/system/media/audio/ui/ChargingStarted.ogg" package="android" defaultValue="/system/media/audio/ui/ChargingStarted.ogg" defaultSysSet="true" />
  <setting id="92" name="device_provisioned" value="1" package="com.google.android.setupwizard" defaultValue="1" defaultSysSet="true" />
  <setting id="69" name="emergency_affordance_needed" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="76" name="sysui_demo_allowed" package="com.android.systemui" />
  <setting id="5" name="auto_time" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="22" name="usb_mass_storage_enabled" value="1" package="android" defaultValue="1" defaultSysSet="true" />
  <setting id="41" name="call_auto_retry" value="0" package="android" defaultValue="0" defaultSysSet="true" />
  <setting id="80" name="audio_safe_volume_state" value="3" package="android" defaultValue="3" defaultSysSet="true" />
  <setting id="109" name="boot_count" value="2" package="android" defaultValue="2" defaultSysSet="true" />
  <setting id="32" name="desk_dock_sound" value="/system/media/audio/ui/Dock.ogg" package="android" defaultValue="/system/media/audio/ui/Dock.ogg" defaultSysSet="true" />
  <setting id="115" name="wifi_saved_state" value="1" package="android" defaultValue="1" defaultSysSet="true" />
</settings>


```


## hostapd.conf

```
ProjectPath:   /device/qcom/wlan/talos/hostapd.conf


```



## /vendor/etc/wifi/WCNSS_qcom_cfg.ini

```
adb pull /vendor/etc/wifi/WCNSS_qcom_cfg.ini
adb push ./WCNSS_qcom_cfg.ini /vendor/etc/wifi/


ProjectPath:   /device/qcom/wlan/talos/WCNSS_qcom_cfg.ini

# This file allows user to override the factory
# defaults for the WLAN Driver

# IKSWO-42425: Enable user triggered SSR
gEnableForceTargetAssert=1

# Enable IMPS or not
gEnableImps=1

# Enable BMPS or not
gEnableBmps=1

# Phy Mode (auto, b, g, n, etc)
# Valid values are 0-9, with 0 = Auto, 4 = 11n, 9 = 11ac
# 1 = 11abg, 2 = 11b, 3 = 11g, 5 = 11g only, 6 = 11n only
# 7 = 11b only 8 = 11ac only.
gDot11Mode=0

# Assigned MAC Addresses - This will be used until NV items are in place
# Each byte of MAC address is represented in Hex format as XX
Intf0MacAddress=000AF58989FF
Intf1MacAddress=000AF58989FE
Intf2MacAddress=000AF58989FD
Intf3MacAddress=000AF58989FC

# UAPSD service interval for VO,VI, BE, BK traffic
InfraUapsdVoSrvIntv=0
InfraUapsdViSrvIntv=0
InfraUapsdBeSrvIntv=0
InfraUapsdBkSrvIntv=0

# Flag to allow STA send AddTspec even when ACM is Off
gAddTSWhenACMIsOff=1

#Flag to enable HostARPOffload feature or not
hostArpOffload=1

#Flag to enable HostNSOffload feature or not
hostNSOffload=1

# 802.11n Protection flag
gEnableApProt=1

#Enable OBSS protection
gEnableApOBSSProt=1

#Enable/Disable UAPSD for SoftAP
gEnableApUapsd=1

# Fixed Rate
gFixedRate=0

# Maximum Tx power
# gTxPowerCap=30

# Fragmentation Threshold
# gFragmentationThreshold=2346

# RTS threshold
RTSThreshold=1048576

# Intra-BSS forward
gDisableIntraBssFwd=0

# WMM Enable/Disable
WmmIsEnabled=0

# 802.11d support
g11dSupportEnabled=0

# 802.11h support
g11hSupportEnabled=1

# DFS Master Capability
gEnableDFSMasterCap=0

# ESE Support and fast transition
EseEnabled=0

ImplicitQosIsEnabled=0

gNeighborScanTimerPeriod=200
gNeighborLookupThreshold=76
gNeighborScanChannelMinTime=20
gNeighborScanChannelMaxTime=30
gMaxNeighborReqTries=3

# Legacy (non-ESE, non-802.11r) Fast Roaming Support
# To enable, set FastRoamEnabled=1
# To disable, set FastRoamEnabled=0
FastRoamEnabled=1

# Check if the AP to which we are roaming is better than current AP in
# terms of RSSI.  Checking is disabled if set to Zero.Otherwise it will
# use this value as to how better the RSSI of the new/roamable AP should
# be for roaming
RoamRssiDiff=5

# To enable, set gRoamIntraBand=1 (Roaming within band)
# To disable, set gRoamIntraBand=0 (Roaming across band)
gRoamIntraBand=0

#Short Guard Interval Enable/disable
gShortGI20Mhz=1
gShortGI40Mhz=1

#Auto Shutdown  Value in seconds. A value of 0 means Auto shutoff is disabled
gAPAutoShutOff=0

#Auto Shutdown wlan : Value in Seconds. 0 means disabled. Max 1 day = 86400 sec
gWlanAutoShutdown = 0

# Not used.
gApAutoChannelSelection=0

#Preferred band (both or 2.4 only or 5 only)
BandCapability=0

#Channel Bonding
gChannelBondingMode5GHz=1

#Say gGoKeepAlivePeriod(5 seconds) and gGoLinkMonitorPeriod(10 seconds).
#For every 10 seconds DUT send Qos Null frame(i.e., Keep Alive frame if link
#is idle for last 10 seconds.) For both active and power save clients.

#Power save clients: DUT set TIM bit from 10th second onwards and till client
#honors TIM bit. If doesn't honor for 5 seconds then DUT remove client.

#Active clients: DUT send Qos Null frame for 10th seconds onwards if it is not
#success still we try on 11th second if not tries on 12th and so on till 15th
#second. Hence before disconnection DUT will send 5 NULL frames. Hence in any
#case DUT will detect client got removed in (10+5) seconds.
#i.e., (gGoKeepAlivePeriod + gGoLinkMonitorPeriod)..

#gGoLinkMonitorPeriod/ gApLinkMonitorPeriod is period where link is idle and
#it is period where we send NULL frame.
#gApLinkMonitorPeriod = 10
#gGoLinkMonitorPeriod = 10

#gGoKeepAlivePeriod/gApKeepAlivePeriod is time to spend to check whether frame
#are succeed to send or not. Hence total effective detection time is
# (gGoLinkMonitorPeriod + gGoKeepAlivePeriod) /
# (gApLinkMonitorPeriod + gApKeepAlivePeriod)
gGoKeepAlivePeriod = 20
gApKeepAlivePeriod = 20

#If set will start with active scan after driver load, otherwise will start with
#passive scan to find out the domain
gEnableBypass11d=1

#If set to 0, will not scan DFS channels
gEnableDFSChnlScan=1

# Enable DFS channel roam
# 0: DISABLE, 1: ENABLED_NORMAL, 2: ENABLED_ACTIVE
gAllowDFSChannelRoam=1

gVhtChannelWidth=2

#Data Inactivity Timeout when in powersave (in ms)
gDataInactivityTimeout=200

# Set txchainmask and rxchainmask
# These parameters are used only if gEnable2x2 is 0
# Valid values are 1,2
# Set gSetTxChainmask1x1=1 or gSetRxChainmask1x1=1 to select chain0.
# Set gSetTxChainmask1x1=2 or gSetRxChainmask1x1=2 to select chain1.
gSetTxChainmask1x1=1
gSetRxChainmask1x1=1

# Scan Timing Parameters
# gPassiveMaxChannelTime=110
# gPassiveMinChannelTime=60
gActiveMaxChannelTime=40
gActiveMinChannelTime=20

#If set to 0, MCC is not allowed.
gEnableMCCMode=1

# MCC to SCC Switch mode:
# 0-Disable
# 1-Enable
# 2-Force SCC if same band, with SAP restart
# 3-Force SCC if same band, without SAP restart by sending (E)CSA
# 4-Force SCC if same band (or) use SAP mandatory channel for DBS,
#   without SAP restart by sending (E)CSA
gWlanMccToSccSwitchMode = 3

# 1=enable STBC; 0=disable STBC
gEnableRXSTBC=1

# 1=enable tx STBC; 0=disable
gEnableTXSTBC=1

# 1=enable rx LDPC; 0=disable
gEnableRXLDPC=1

#Enable/Disable Tx beamforming
gTxBFEnable=1

#Enable/Disable Tx beamformee in SAP mode
gEnableTxBFeeSAP=1

# Enable Tx beamforming in VHT20MHz
# Valid values are 0,1. If commented out, the default value is 0.
# 0=disable, 1=enable
gEnableTxBFin20MHz=1

#Enable/Disable SU Tx beamformer support.
gEnableTxSUBeamformer=1

gEnableFastRoamInConcurrency=1

#Enable/Disable PER based roaming
gper_roam_enabled=0

#Maxium Channel time in msec
gMaxMediumTime = 6000

# 802.11K support
gRrmEnable=1

#Enable Power Save offload
gEnablePowerSaveOffload=2

#Enable firmware uart print
gEnablefwprint=0

# Firmware log mode
# Valid values are 0,1,2
# 0=Disable, 1=WMI, 2=DIAG
gEnablefwlog=1

# Maximum Receive AMPDU size (VHT only. Valid values:
# 0->8k 1->16k 2->32k 3->64k 4->128k)
gVhtAmpduLenExponent=7

# Maximum MPDU length (VHT only. Valid values:
# 0->3895 octets, 1->7991 octets, 2->11454 octets)
gVhtMpduLen=2

# Maximum number of wow filters required
#gMaxWoWFilters=22

# WOW Enable/Disable.
# 0 - Disable both magic pattern match and pattern byte match.
# 1 - Enable magic pattern match on all interfaces.
# 2 - Enable pattern byte match on all interfaces.
# 3 - Enable both magic pattern and pattern byte match on all interfaces.
# Default value of gEnableWoW is 3.
# gEnableWoW=0

# Enable or Disable MCC Adaptive Scheduler at the FW
# 1=Enable (default), 0=Disable
gEnableMCCAdaptiveScheduler=1

#Enable or Disable p2p device address administered
isP2pDeviceAddrAdministrated=1

# Set Thermal Power limit
TxPower2g=30
TxPower5g=30

# Remove Overlap channel restriction
gEnableOverLapCh=0

#Enable VHT on 2.4Ghz
gEnableVhtFor24GHzBand=1

#Maximum number of offload peers supported
# gMaxOffloadPeers=2

# controlling the following offload patterns
# through ini parameter. Default value is 1
# to disable set it to zero. ssdp = 0
# Setup multicast pattern for mDNS 224.0.0.251,
# SSDP 239.255.255.250 and LLMNR 224.0.0.252
ssdp=0

#Enable Memory Deep Sleep
gEnableMemDeepSleep=1

# Regulatory Setting; 0=STRICT; 1=CUSTOM
gRegulatoryChangeCountry=1

# RA filtering rate limit param, the current value would not
# help if the lifetime in RA is less than 3*60=3min. Then
# we need to change it, though it is uncommon.
# gRAFilterEnable=0
gRArateLimitInterval=600

# Maximum number of concurrent connections
gMaxConcurrentActiveSessions=3

# Disable/Enable GreenAP
# 0 to disable, 1 to enable, default: 1
gEnableGreenAp=1

# Disable/Enable EGAP
gEnableEGAP=1
gEGAPWaitTime=150
gEGAPFeatures=3

gIgnorePeerErpInfo=1


# Radar PRI multiplier
gDFSradarMappingPriMultiplier=4

gPNOScanSupport=1

#Enable/Disable LPASS support
# 0 to disable, 1 to enable
gEnableLpassSupport=1

# Whether userspace country code setting shld have priority
gCountryCodePriority=1

# Enable(1)/Disable(0) SIFS burst
gEnableSifsBurst=1

# Enable or Disable Multi-user MIMO
# 1=Enable (default), 0=Disable
gEnableMuBformee=1

# Enable/Disable channel avoidance for SAP in SCC scenario
# 0 - disable
# 1 - enable
gSapSccChanAvoidance=0

# Inactivity time (in ms) to end TX Service Period while in IBSS power save mode
gIbssTxSpEndInactivityTime=10

# Enable support for TDLS
#  0 - disable
#  1 - enable
gEnableTDLSSupport=1

# Enable support for Implicit Trigger of TDLS. That is, wlan driver shall
# initiate TDLS Discovery towards a peer whenever setup criteria (throughput
# and RSSI) is met and then will initiate teardown when teardown criteria
# (idle packet count and RSSI) is met.
#  0 - disable
#  1 - enable
gEnableTDLSImplicitTrigger=1

# Enable TDLS External Control. That is, user space application has to
# first configure a peer MAC in wlan driver towards which TDLS is desired.
# Device will establish TDLS only towards those configured peers whenever
# TDLS criteria (throughput and RSSI threshold) is met and teardown TDLS
# when teardown criteria (idle packet count and RSSI) is met. However,
# device will accept TDLS connection if it is initiated from any other peer,
# even if that peer is not configured.
#  0 - disable
#  1 - enable
# For TDLS External Control, Implicit Trigger must also be enabled.
gTDLSExternalControl=1

# Enable support for TDLS off-channel operation
#  0 - disable
#  1 - enable
# TDLS off-channel operation will be invoked when there is only one
# TDLS connection.
gEnableTDLSOffChannel=0
gEnableTDLSScan=1
gTDLSTxStatsPeriod=500
gTDLSTxPacketThreshold=10
gTDLSIdlePacketThreshold=1

# Enable or Disable Random MAC (Spoofing)
# 1=Enable (default), 0=Disable
gEnableMacAddrSpoof=1

################ Datapath feature set Begin ################
# Bus bandwidth threshold values in terms of number of packets
gBusBandwidthHighThreshold=2000
gBusBandwidthMediumThreshold=500
gBusBandwidthLowThreshold=150

# Bus bandwidth compute timeout value in ms
gBusBandwidthComputeInterval=100

# VHT Tx/Rx MCS values
# Valid values are 0,1,2. If commented out, the default value is 0.
# 0=MCS0-7, 1=MCS0-8, 2=MCS0-9
gVhtRxMCS=2
gVhtTxMCS=2

# VHT Tx/Rx MCS values for 2x2
# Valid values are 0,1,2. If commented out, the default value is 0.
# 0=MCS0-7, 1=MCS0-8, 2=MCS0-9
gEnable2x2=1
gVhtRxMCS2x2=2
gVhtTxMCS2x2=2

#IPA config is a bit mask and following are the configurations.
#bit0 IPA Enable
#bit1 IPA PRE Filter enable
#bit2 IPv6 enable
#bit3 IPA Resource Manager (RM) enable
#bit4 IPA Clock scaling enable
#bit5 IPA uC ENABLE
#bit6 IPA uC STA ENABLE
#bit8 IPA Real Time Debugging
gIPAConfig=0x7d
gIPADescSize=800

# Enable/Disable RX full reorder offload
gReorderOffloadSupported=1

# Enable CE classification
# 1 - enable(default)  0 - disable
gCEClassifyEnable=1

# Enable Rx handling options
# Rx_thread=1 RPS=2(default for ROME) NAPI=4(default for ihelium)
rx_mode=5

# Enable(Tx) fastpath for data traffic.
# 1 - enable(default)  0 - disable
gEnableFastPath=1

# This flag enables IP, TCP and UDP checksum offload
# 1 - enable(default)  0 - disable
gEnableIpTcpUdpChecksumOffload=1

# Enable TCP Segmentation Offload
# 1 - enable  0 - disable
TSOEnable=1

# Enable Generic Receive Offload
# 1 - enable(default)  0 - disable
GROEnable=1

# Enable HT MPDU Density
# 4 for 2 micro sec
ght_mpdu_density=4

# Enable flow steering to enable multiple CEs for Rx flows.
# Multiple Rx CEs<==>Multiple Rx IRQs<==>probably different CPUs.
# Parallel Rx paths.
# 1 - enable 0 - disable(default)
gEnableFlowSteering=1

# Time in microseconds after which a NAPI poll must yield
ce_service_max_yield_time=500

#Maximum number of HTT messages to be processed per NAPI poll
ce_service_max_rx_ind_flush=1

# Maximum number of MSDUs the firmware will pack in one HTT_T2H_MSG_TYPE_RX_IN_ORD_PADDR_IND
maxMSDUsPerRxInd=8

# Enable NUD tracking feature
# 1 - enable 0 - disable(default)
gEnableNUDTracking=1

# Enable PEER UNMAP CONF SUPPORT
# 1 - enable 0 - disable(default)
gEnablePeerUnmapConfSupport=1

################ Datapath feature set End ################

################ NAN feature set start ###################

# Enable NAN discovery (NAN 1.0)
# 1 - enable  0 - disable(default)
gEnableNanSupport=0

################ NAN feature set end #####################

# Enable/Disable FILS support in driver
# 1 - enable(default)  0 - disable
g_is_fils_enabled=0

# Flag to enable/disable FILS element in Probe Request
g_enable_bcast_probe_rsp=0

adaptive_dwell_mode_enabled=1

hostscan_adaptive_dwell_mode=1

adapt_dwell_lpf_weight=80

adapt_dwell_wifi_act_threshold=10

MAWCEnabled=0

drop_bcn_on_chan_mismatch=0

# Enable/Disable rtt sta mac randomization
enable_rtt_mac_randomization=1

#Enable/Disable SNR monitoring
gEnableSNRMonitoring=1

#Enable/Disable LPRx
gEnableLPRx=0

# Enable the FW crash inject
gEnableForceTargetAssert=1

END

# Note: Configuration parser would not read anything past the END marker




```




## /vendor/etc/wifi/wpa_supplicant.conf

```
adb pull /vendor/etc/wifi/wpa_supplicant.conf  .
adb push ./wpa_supplicant.conf  /vendor/etc/wifi/

update_config=1
ctrl_interface=wlan0
eapol_version=1
ap_scan=1
fast_reauth=1
p2p_add_cli_chan=1
p2p_no_group_iface=1
config_methods=virtual_display virtual_push_button
disable_scan_offload=1



```

### update_config

```

# Whether to allow wpa_supplicant to update (overwrite) configuration
#
# This option can be used to allow wpa_supplicant to overwrite configuration
# file whenever configuration is changed (e.g., new network block is added with
# wpa_cli or wpa_gui, or a password is changed). This is required for
# wpa_cli/wpa_gui to be able to store the configuration changes permanently.
# Please note that overwriting configuration file will remove the comments from
# it.

update_config=1
```

### ctrl_interface

```
# global configuration (shared by all network blocks)
#
# Parameters for the control interface. If this is specified, wpa_supplicant
# will open a control interface that is available for external programs to
# manage wpa_supplicant. The meaning of this string depends on which control
# interface mechanism is used. For all cases, the existance of this parameter
# in configuration is used to determine whether the control interface is
# enabled.
#
# For UNIX domain sockets (default on Linux and BSD): This is a directory that
# will be created for UNIX domain sockets for listening to requests from
# external programs (CLI/GUI, etc.) for status information and configuration.
# The socket file will be named based on the interface name, so multiple
# wpa_supplicant processes can be run at the same time if more than one
# interface is used.
# /var/run/wpa_supplicant is the recommended directory for sockets and by
# default, wpa_cli will use it when trying to connect with wpa_supplicant.
#
# Access control for the control interface can be configured by setting the
# directory to allow only members of a group to use sockets. This way, it is
# possible to run wpa_supplicant as root (since it needs to change network
# configuration and open raw sockets) and still allow GUI/CLI components to be
# run as non-root users. However, since the control interface can be used to
# change the network configuration, this access needs to be protected in many
# cases. By default, wpa_supplicant is configured to use gid 0 (root). If you
# want to allow non-root users to use the control interface, add a new group
# and change this value to match with that group. Add users that should have
# control interface access to this group. If this variable is commented out or
# not included in the configuration file, group will not be changed from the
# value it got by default when the directory or socket was created.

ctrl_interface=wlan0
```

### eapol_version

```
# IEEE 802.1X/EAPOL version
# wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which defines
# EAPOL version 2. However, there are many APs that do not handle the new
# version number correctly (they seem to drop the frames completely). In order
# to make wpa_supplicant interoperate with these APs, the version number is set
# to 1 by default. This configuration value can be used to set it to the new
# version (2).

eapol_version=1


```

### ap_scan

```
# AP scanning/selection
# By default, wpa_supplicant requests driver to perform AP scanning and then
# uses the scan results to select a suitable AP. Another alternative is to
# allow the driver to take care of AP scanning and selection and use
# wpa_supplicant just to process EAPOL frames based on IEEE 802.11 association
# information from the driver.
# 1: wpa_supplicant initiates scanning and AP selection
# 0: driver takes care of scanning, AP selection, and IEEE 802.11 association
#    parameters (e.g., WPA IE generation); this mode can also be used with
#    non-WPA drivers when using IEEE 802.1X mode; do not try to associate with
#    APs (i.e., external program needs to control association). This mode must
#    also be used when using wired Ethernet drivers.
# 2: like 0, but associate with APs using security policy and SSID (but not
#    BSSID); this can be used, e.g., with ndiswrapper and NDIS drivers to
#    enable operation with hidden SSIDs and optimized roaming; in this mode,
#    the network blocks in the configuration file are tried one by one until
#    the driver reports successful association; each network block should have
#    explicit security policy (i.e., only one option in the lists) for
#    key_mgmt, pairwise, group, proto variables

ap_scan=1
```

### fast_reauth

```
# EAP fast re-authentication
# By default, fast re-authentication is enabled for all EAP methods that
# support it. This variable can be used to disable fast re-authentication.
# Normally, there is no need to disable this.
fast_reauth=1

```





### disable_scan_offload

```
# disable_scan_offload - Disable automatic offloading of scan requests
# By default, wpa_supplicant tries to offload scanning if the driver
# indicates support for this (sched_scan). This configuration
# parameter can be used to disable this offloading mechanism.
disable_scan_offload=1


```


### load_dynamic_eap

```
# Dynamic EAP methods
# If EAP methods were built dynamically as shared object files, they need to be
# loaded here before being used in the network blocks. By default, EAP methods
# are included statically in the build, so these lines are not needed

load_dynamic_eap=/usr/lib/wpa_supplicant/eap_tls.so
load_dynamic_eap=/usr/lib/wpa_supplicant/eap_md5.so

```


### driver_param
```

# Driver interface parameters
# This field can be used to configure arbitrary driver interace parameters. The
# format is specific to the selected driver interface. This field is not used
# in most cases.
driver_param="field=value"

```


### country

```
# Country code
# The ISO/IEC alpha2 country code for the country in which this device is
# currently operating.
country=US

```

### dot11RSNAConfigPMKLifetime

```
# Maximum lifetime for PMKSA in seconds; default 43200
dot11RSNAConfigPMKLifetime=43200

```

### dot11RSNAConfigPMKReauthThreshold

```
# Threshold for reauthentication (percentage of PMK lifetime); default 70
dot11RSNAConfigPMKReauthThreshold=70

```

### dot11RSNAConfigSATimeout

```

# Timeout for security association negotiation in seconds; default 60
dot11RSNAConfigSATimeout=60

```

### config_methods

```
# Wi-Fi Protected Setup (WPS) parameters
# Config Methods
# List of the supported configuration methods
# Available methods: usba ethernet label display ext_nfc_token int_nfc_token
#   nfc_interface push_button keypad virtual_display physical_display
#   virtual_push_button physical_push_button
# For WSC 2.0:

config_methods=virtual_display virtual_push_button

```

### uuid

```

# Universally Unique IDentifier (UUID; see RFC 4122) of the device
# If not configured, UUID will be generated based on the local MAC address.
#uuid=12345678-9abc-def0-1234-56789abcdef0

```


### device_name

```
# Device Name
# User-friendly description of device; up to 32 octets encoded in UTF-8
device_name=Wireless Client

```

### wps_cred_processing

```
# Credential processing
#   0 = process received credentials internally (default)
#   1 = do not process received credentials; just pass them over ctrl_iface to
#	external program(s)
#   2 = process received credentials internally and pass them over ctrl_iface
#	to external program(s)
wps_cred_processing=0

```

### p2p_no_group_iface

```
# Seperate Group interface creation
#  1 = use same inteface for GO
#  0 = use separate interface per GO (for driver)
p2p_no_group_iface=1

```

### network_block网络字段说明

```

# network block
#
# Each network (usually AP's sharing the same SSID) is configured as a separate
# block in this configuration file. The network blocks are in preference order
# (the first match is used).
#
# network block fields:
#
# disabled:
#	0 = this network can be used (default)
#	1 = this network block is disabled (can be enabled through ctrl_iface,
#	    e.g., with wpa_cli or wpa_gui)
#
# id_str: Network identifier string for external scripts. This value is passed
#	to external action script through wpa_cli as WPA_ID_STR environment
#	variable to make it easier to do network specific configuration.
#
# ssid: SSID (mandatory); either as an ASCII string with double quotation or
#	as hex string; network name
#
# scan_ssid:
#	0 = do not scan this SSID with specific Probe Request frames (default)
#	1 = scan with SSID-specific Probe Request frames (this can be used to
#	    find APs that do not accept broadcast SSID or use multiple SSIDs;
#	    this will add latency to scanning, so enable this only when needed)
#
# bssid: BSSID (optional); if set, this network block is used only when
#	associating with the AP using the configured BSSID
#
# priority: priority group (integer)
# By default, all networks will get same priority group (0). If some of the
# networks are more desirable, this field can be used to change the order in
# which wpa_supplicant goes through the networks when selecting a BSS. The
# priority groups will be iterated in decreasing priority (i.e., the larger the
# priority value, the sooner the network is matched against the scan results).
# Within each priority group, networks will be selected based on security
# policy, signal strength, etc.
# Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are not
# using this priority to select the order for scanning. Instead, they try the
# networks in the order that used in the configuration file.
#
# mode: IEEE 802.11 operation mode
# 0 = infrastructure (Managed) mode, i.e., associate with an AP (default)
# 1 = IBSS (ad-hoc, peer-to-peer)
# Note: IBSS can only be used with key_mgmt NONE (plaintext and static WEP)
# and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In addition, ap_scan has
# to be set to 2 for IBSS. WPA-None requires following network block options:
# proto=WPA, key_mgmt=WPA-NONE, pairwise=NONE, group=TKIP (or CCMP, but not
# both), and psk must also be set.
#
# frequency: Channel frequency in megahertz (MHz) for IBSS, e.g.,
# 2412 = IEEE 802.11b/g channel 1. This value is used to configure the initial
# channel for IBSS (adhoc) networks. It is ignored in the infrastructure mode.
# In addition, this value is only used by the station that creates the IBSS. If
# an IBSS network with the configured SSID is already present, the frequency of
# the network will be used instead of this configured value.
#
# proto: list of accepted protocols
# WPA = WPA/IEEE 802.11i/D3.0
# RSN = WPA2/IEEE 802.11i (also WPA2 can be used as an alias for RSN)
# If not set, this defaults to: WPA RSN
#
# key_mgmt: list of accepted authenticated key management protocols
# WPA-PSK = WPA pre-shared key (this requires 'psk' field)
# WPA-EAP = WPA using EAP authentication
# IEEE8021X = IEEE 802.1X using EAP authentication and (optionally) dynamically
#	generated WEP keys
# NONE = WPA is not used; plaintext or static WEP could be used
# WPA-PSK-SHA256 = Like WPA-PSK but using stronger SHA256-based algorithms
# WPA-EAP-SHA256 = Like WPA-EAP but using stronger SHA256-based algorithms
# If not set, this defaults to: WPA-PSK WPA-EAP
#
# auth_alg: list of allowed IEEE 802.11 authentication algorithms
# OPEN = Open System authentication (required for WPA/WPA2)
# SHARED = Shared Key authentication (requires static WEP keys)
# LEAP = LEAP/Network EAP (only used with LEAP)
# If not set, automatic selection is used (Open System with LEAP enabled if
# LEAP is allowed as one of the EAP methods).
#
# pairwise: list of accepted pairwise (unicast) ciphers for WPA
# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
# NONE = Use only Group Keys (deprecated, should not be included if APs support
#	pairwise keys)
# If not set, this defaults to: CCMP TKIP
#
# group: list of accepted group (broadcast/multicast) ciphers for WPA
# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
# WEP104 = WEP (Wired Equivalent Privacy) with 104-bit key
# WEP40 = WEP (Wired Equivalent Privacy) with 40-bit key [IEEE 802.11]
# If not set, this defaults to: CCMP TKIP WEP104 WEP40
#
# psk: WPA preshared key; 256-bit pre-shared key
# The key used in WPA-PSK mode can be entered either as 64 hex-digits, i.e.,
# 32 bytes or as an ASCII passphrase (in which case, the real PSK will be
# generated using the passphrase and SSID). ASCII passphrase must be between
# 8 and 63 characters (inclusive).
# This field is not needed, if WPA-EAP is used.
# Note: Separate tool, wpa_passphrase, can be used to generate 256-bit keys
# from ASCII passphrase. This process uses lot of CPU and wpa_supplicant
# startup and reconfiguration time can be optimized by generating the PSK only
# only when the passphrase or SSID has actually changed.
#
# eapol_flags: IEEE 802.1X/EAPOL options (bit field)
# Dynamic WEP key required for non-WPA mode
# bit0 (1): require dynamically generated unicast WEP key
# bit1 (2): require dynamically generated broadcast WEP key
# 	(3 = require both keys; default)
# Note: When using wired authentication, eapol_flags must be set to 0 for the
# authentication to be completed successfully.
#
# mixed_cell: This option can be used to configure whether so called mixed
# cells, i.e., networks that use both plaintext and encryption in the same
# SSID, are allowed when selecting a BSS form scan results.
# 0 = disabled (default)
# 1 = enabled
#
# proactive_key_caching:
# Enable/disable opportunistic PMKSA caching for WPA2.
# 0 = disabled (default)
# 1 = enabled
#
# wep_key0..3: Static WEP key (ASCII in double quotation, e.g. "abcde" or
# hex without quotation, e.g., 0102030405)
# wep_tx_keyidx: Default WEP key index (TX) (0..3)
#
# peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e DLS) is
# allowed. This is only used with RSN/WPA2.
# 0 = disabled (default)
# 1 = enabled
#peerkey=1
#
# wpa_ptk_rekey: Maximum lifetime for PTK in seconds. This can be used to
# enforce rekeying of PTK to mitigate some attacks against TKIP deficiencies.
#
# Following fields are only used with internal EAP implementation.
# eap: space-separated list of accepted EAP methods
#	MD5 = EAP-MD5 (unsecure and does not generate keying material ->
#			cannot be used with WPA; to be used as a Phase 2 method
#			with EAP-PEAP or EAP-TTLS)
#       MSCHAPV2 = EAP-MSCHAPv2 (cannot be used separately with WPA; to be used
#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
#       OTP = EAP-OTP (cannot be used separately with WPA; to be used
#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
#       GTC = EAP-GTC (cannot be used separately with WPA; to be used
#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
#	TLS = EAP-TLS (client and server certificate)
#	PEAP = EAP-PEAP (with tunnelled EAP authentication)
#	TTLS = EAP-TTLS (with tunnelled EAP or PAP/CHAP/MSCHAP/MSCHAPV2
#			 authentication)
#	If not set, all compiled in methods are allowed.
#
# identity: Identity string for EAP
#	This field is also used to configure user NAI for
#	EAP-PSK/PAX/SAKE/GPSK.
# anonymous_identity: Anonymous identity string for EAP (to be used as the
#	unencrypted identity with EAP types that support different tunnelled
#	identity, e.g., EAP-TTLS)
# password: Password string for EAP. This field can include either the
#	plaintext password (using ASCII or hex string) or a NtPasswordHash
#	(16-byte MD4 hash of password) in hash:<32 hex digits> format.
#	NtPasswordHash can only be used when the password is for MSCHAPv2 or
#	MSCHAP (EAP-MSCHAPv2, EAP-TTLS/MSCHAPv2, EAP-TTLS/MSCHAP, LEAP).
#	EAP-PSK (128-bit PSK), EAP-PAX (128-bit PSK), and EAP-SAKE (256-bit
#	PSK) is also configured using this field. For EAP-GPSK, this is a
#	variable length PSK.
# ca_cert: File path to CA certificate file (PEM/DER). This file can have one
#	or more trusted CA certificates. If ca_cert and ca_path are not
#	included, server certificate will not be verified. This is insecure and
#	a trusted CA certificate should always be configured when using
#	EAP-TLS/TTLS/PEAP. Full path should be used since working directory may
#	change when wpa_supplicant is run in the background.
#	On Windows, trusted CA certificates can be loaded from the system
#	certificate store by setting this to cert_store://<name>, e.g.,
#	ca_cert="cert_store://CA" or ca_cert="cert_store://ROOT".
#	Note that when running wpa_supplicant as an application, the user
#	certificate store (My user account) is used, whereas computer store
#	(Computer account) is used when running wpasvc as a service.
# ca_path: Directory path for CA certificate files (PEM). This path may
#	contain multiple CA certificates in OpenSSL format. Common use for this
#	is to point to system trusted CA list which is often installed into
#	directory like /etc/ssl/certs. If configured, these certificates are
#	added to the list of trusted CAs. ca_cert may also be included in that
#	case, but it is not required.
# client_cert: File path to client certificate file (PEM/DER)
#	Full path should be used since working directory may change when
#	wpa_supplicant is run in the background.
#	Alternatively, a named configuration blob can be used by setting this
#	to blob://<blob name>.
# private_key: File path to client private key file (PEM/DER/PFX)
#	When PKCS#12/PFX file (.p12/.pfx) is used, client_cert should be
#	commented out. Both the private key and certificate will be read from
#	the PKCS#12 file in this case. Full path should be used since working
#	directory may change when wpa_supplicant is run in the background.
#	Windows certificate store can be used by leaving client_cert out and
#	configuring private_key in one of the following formats:
#	cert://substring_to_match
#	hash://certificate_thumbprint_in_hex
#	for example: private_key="hash://63093aa9c47f56ae88334c7b65a4"
#	Note that when running wpa_supplicant as an application, the user
#	certificate store (My user account) is used, whereas computer store
#	(Computer account) is used when running wpasvc as a service.
#	Alternatively, a named configuration blob can be used by setting this
#	to blob://<blob name>.
# private_key_passwd: Password for private key file (if left out, this will be
#	asked through control interface)
# dh_file: File path to DH/DSA parameters file (in PEM format)
#	This is an optional configuration file for setting parameters for an
#	ephemeral DH key exchange. In most cases, the default RSA
#	authentication does not use this configuration. However, it is possible
#	setup RSA to use ephemeral DH key exchange. In addition, ciphers with
#	DSA keys always use ephemeral DH keys. This can be used to achieve
#	forward secrecy. If the file is in DSA parameters format, it will be
#	automatically converted into DH params.
# subject_match: Substring to be matched against the subject of the
#	authentication server certificate. If this string is set, the server
#	sertificate is only accepted if it contains this string in the subject.
#	The subject string is in following format:
#	/C=US/ST=CA/L=San Francisco/CN=Test AS/emailAddress=as@example.com
# altsubject_match: Semicolon separated string of entries to be matched against
#	the alternative subject name of the authentication server certificate.
#	If this string is set, the server sertificate is only accepted if it
#	contains one of the entries in an alternative subject name extension.
#	altSubjectName string is in following format: TYPE:VALUE
#	Example: EMAIL:server@example.com
#	Example: DNS:server.example.com;DNS:server2.example.com
#	Following types are supported: EMAIL, DNS, URI
# phase1: Phase1 (outer authentication, i.e., TLS tunnel) parameters
#	(string with field-value pairs, e.g., "peapver=0" or
#	"peapver=1 peaplabel=1")
#	'peapver' can be used to force which PEAP version (0 or 1) is used.
#	'peaplabel=1' can be used to force new label, "client PEAP encryption",
#	to be used during key derivation when PEAPv1 or newer. Most existing
#	PEAPv1 implementation seem to be using the old label, "client EAP
#	encryption", and wpa_supplicant is now using that as the default value.
#	Some servers, e.g., Radiator, may require peaplabel=1 configuration to
#	interoperate with PEAPv1; see eap_testing.txt for more details.
#	'peap_outer_success=0' can be used to terminate PEAP authentication on
#	tunneled EAP-Success. This is required with some RADIUS servers that
#	implement draft-josefsson-pppext-eap-tls-eap-05.txt (e.g.,
#	Lucent NavisRadius v4.4.0 with PEAP in "IETF Draft 5" mode)
#	include_tls_length=1 can be used to force wpa_supplicant to include
#	TLS Message Length field in all TLS messages even if they are not
#	fragmented.
#	sim_min_num_chal=3 can be used to configure EAP-SIM to require three
#	challenges (by default, it accepts 2 or 3)
#	result_ind=1 can be used to enable EAP-SIM and EAP-AKA to use
#	protected result indication.
#	'crypto_binding' option can be used to control PEAPv0 cryptobinding
#	behavior:
#	 * 0 = do not use cryptobinding (default)
#	 * 1 = use cryptobinding if server supports it
#	 * 2 = require cryptobinding
#	EAP-WSC (WPS) uses following options: pin=<Device Password> or
#	pbc=1.
# phase2: Phase2 (inner authentication with TLS tunnel) parameters
#	(string with field-value pairs, e.g., "auth=MSCHAPV2" for EAP-PEAP or
#	"autheap=MSCHAPV2 autheap=MD5" for EAP-TTLS)
# Following certificate/private key fields are used in inner Phase2
# authentication when using EAP-TTLS or EAP-PEAP.
# ca_cert2: File path to CA certificate file. This file can have one or more
#	trusted CA certificates. If ca_cert2 and ca_path2 are not included,
#	server certificate will not be verified. This is insecure and a trusted
#	CA certificate should always be configured.
# ca_path2: Directory path for CA certificate files (PEM)
# client_cert2: File path to client certificate file
# private_key2: File path to client private key file
# private_key2_passwd: Password for private key file
# dh_file2: File path to DH/DSA parameters file (in PEM format)
# subject_match2: Substring to be matched against the subject of the
#	authentication server certificate.
# altsubject_match2: Substring to be matched against the alternative subject
#	name of the authentication server certificate.
#
# fragment_size: Maximum EAP fragment size in bytes (default 1398).
#	This value limits the fragment size for EAP methods that support
#	fragmentation (e.g., EAP-TLS and EAP-PEAP). This value should be set
#	small enough to make the EAP messages fit in MTU of the network
#	interface used for EAPOL. The default value is suitable for most
#	cases.
#
# EAP-FAST variables:
# pac_file: File path for the PAC entries. wpa_supplicant will need to be able
#	to create this file and write updates to it when PAC is being
#	provisioned or refreshed. Full path to the file should be used since
#	working directory may change when wpa_supplicant is run in the
#	background. Alternatively, a named configuration blob can be used by
#	setting this to blob://<blob name>
# phase1: fast_provisioning option can be used to enable in-line provisioning
#         of EAP-FAST credentials (PAC):
#         0 = disabled,
#         1 = allow unauthenticated provisioning,
#         2 = allow authenticated provisioning,
#         3 = allow both unauthenticated and authenticated provisioning
#	fast_max_pac_list_len=<num> option can be used to set the maximum
#		number of PAC entries to store in a PAC list (default: 10)
#	fast_pac_format=binary option can be used to select binary format for
#		storing PAC entries in order to save some space (the default
#		text format uses about 2.5 times the size of minimal binary
#		format)
#
# wpa_supplicant supports number of "EAP workarounds" to work around
# interoperability issues with incorrectly behaving authentication servers.
# These are enabled by default because some of the issues are present in large
# number of authentication servers. Strict EAP conformance mode can be
# configured by disabling workarounds with eap_workaround=0.


```

### 预置网络实例

#### WPA-PSK网络配置1

```
# Simple case: WPA-PSK, PSK as an ASCII passphrase, allow all valid ciphers
network={
	ssid="simple"
	psk="very secret passphrase"
	priority=5
}

```

#### WPA-PSK网络配置2

```
## Same as previous, but request SSID-specific scanning (for APs that reject broadcast SSID)
network={
	ssid="second ssid"
	scan_ssid=1
	psk="very secret passphrase"
	priority=2
}


```


#### WPA-PSK网络配置3

```
## Only WPA-PSK is used. Any valid cipher combination is accepted.
network={
	ssid="example"
	proto=WPA
	key_mgmt=WPA-PSK
	pairwise=CCMP TKIP
	group=CCMP TKIP WEP104 WEP40
	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
	priority=2
}

```

#### WPA-PSK(TKIP)网络配置4

```

## WPA-Personal(PSK) with TKIP and enforcement for frequent PTK rekeying
network={
	ssid="example"
	proto=WPA
	key_mgmt=WPA-PSK
	pairwise=TKIP
	group=TKIP
	psk="not so secure passphrase"
	wpa_ptk_rekey=600
}

```

####  WPA-EAP 网络

```
## Only WPA-EAP is used. Both CCMP and TKIP is accepted. An AP that used WEP104
## or WEP40 as the group cipher will not be accepted.
network={
	ssid="example"
	proto=RSN
	key_mgmt=WPA-EAP
	pairwise=CCMP TKIP
	group=CCMP TKIP
	eap=TLS
	identity="user@example.com"
	ca_cert="/etc/cert/ca.pem"
	client_cert="/etc/cert/user.pem"
	private_key="/etc/cert/user.prv"
	private_key_passwd="password"
	priority=1
}


```


#### EAP-PEAP/MSCHAPv2

```

## EAP-PEAP/MSCHAPv2 configuration for RADIUS servers that use the new peaplabel
## (e.g., Radiator)
network={
	ssid="example"
	key_mgmt=WPA-EAP
	eap=PEAP
	identity="user@example.com"
	password="foobar"
	ca_cert="/etc/cert/ca.pem"
	phase1="peaplabel=1"
	phase2="auth=MSCHAPV2"
	priority=10
}

```


#### EAP-TTLS/EAP-MD5-Challenge

```

## EAP-TTLS/EAP-MD5-Challenge configuration with anonymous identity for the
## unencrypted use. Real identity is sent only within an encrypted TLS tunnel.
network={
	ssid="example"
	key_mgmt=WPA-EAP
	eap=TTLS
	identity="user@example.com"
	anonymous_identity="anonymous@example.com"
	password="foobar"
	ca_cert="/etc/cert/ca.pem"
	priority=2
}


```



#### EAP-TTLS/MSCHAPv2

```
## EAP-TTLS/MSCHAPv2 configuration with anonymous identity for the unencrypted
## use. Real identity is sent only within an encrypted TLS tunnel.
network={
	ssid="example"
	key_mgmt=WPA-EAP
	eap=TTLS
	identity="user@example.com"
	anonymous_identity="anonymous@example.com"
	password="foobar"
	ca_cert="/etc/cert/ca.pem"
	phase2="auth=MSCHAPV2"
}


```

#### WPA-EAP/EAP-TTLS/Different_CA_Certificate

```

## WPA-EAP, EAP-TTLS with different CA certificate used for outer and inner
## authentication.
network={
	ssid="example"
	key_mgmt=WPA-EAP
	eap=TTLS
	# Phase1 / outer authentication
	anonymous_identity="anonymous@example.com"
	ca_cert="/etc/cert/ca.pem"
	# Phase 2 / inner authentication
	phase2="autheap=TLS"
	ca_cert2="/etc/cert/ca2.pem"
	client_cert2="/etc/cer/user.pem"
	private_key2="/etc/cer/user.prv"
	private_key2_passwd="password"
	priority=2
}

```

#### WPA-PSK/WPA-EAP/CCMP

```
## Both WPA-PSK and WPA-EAP is accepted. Only CCMP is accepted as pairwise and
## group cipher.
network={
	ssid="example"
	bssid=00:11:22:33:44:55
	proto=WPA RSN
	key_mgmt=WPA-PSK WPA-EAP
	pairwise=CCMP
	group=CCMP
	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
}




```


#### WPA-PSK/WPA-EAP/(Special characters in SSID)

```
## Special characters in SSID, so use hex string. Default to WPA-PSK, WPA-EAP
## and all valid ciphers.
network={
	ssid=00010203
	psk=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
}

```



#### EAP-SIM

```
## EAP-SIM with a GSM SIM or USIM
network={
	ssid="eap-sim-test"
	key_mgmt=WPA-EAP
	eap=SIM
	pin="1234"
	pcsc=""
}

```

#### EAP-PSK

```

## EAP-PSK
network={
	ssid="eap-psk-test"
	key_mgmt=WPA-EAP
	eap=PSK
	anonymous_identity="eap_psk_user"
	password=06b4be19da289f475aa46a33cb793029
	identity="eap_psk_user@example.com"
}

```

#### 802.1X/EAP-TLS/EAPOL(WEP NO-WPA)

```
## IEEE 802.1X/EAPOL with dynamically generated WEP keys (i.e., no WPA) using
## EAP-TLS for authentication and key generation; require both unicast and
## broadcast WEP keys.
network={
	ssid="1x-test"
	key_mgmt=IEEE8021X
	eap=TLS
	identity="user@example.com"
	ca_cert="/etc/cert/ca.pem"
	client_cert="/etc/cert/user.pem"
	private_key="/etc/cert/user.prv"
	private_key_passwd="password"
	eapol_flags=3
}

```


#### LEAP

```
# LEAP with dynamic WEP keys
network={
	ssid="leap-example"
	key_mgmt=IEEE8021X
	eap=LEAP
	identity="user"
	password="foobar"
}


```



#### EAP-IKEv2

```
## EAP-IKEv2 using shared secrets for both server and peer authentication
network={
	ssid="ikev2-example"
	key_mgmt=WPA-EAP
	eap=IKEV2
	identity="user"
	password="foobar"
}

```



#### EAP-FAST

```
## EAP-FAST with WPA (WPA or WPA2)
network={
	ssid="eap-fast-test"
	key_mgmt=WPA-EAP
	eap=FAST
	anonymous_identity="FAST-000102030405"
	identity="username"
	password="password"
	phase1="fast_provisioning=1"
	pac_file="/etc/wpa_supplicant.eap-fast-pac"
}



network={
	ssid="eap-fast-test"
	key_mgmt=WPA-EAP
	eap=FAST
	anonymous_identity="FAST-000102030405"
	identity="username"
	password="password"
	phase1="fast_provisioning=1"
	pac_file="blob://eap-fast-pac"
}

```


#### Plaintext connection|open network开放网络

```
## Plaintext connection (no WPA, no IEEE 802.1X)
network={
	ssid="plaintext-test"
	key_mgmt=NONE
}

```
#### Shared WEP key connection (no WPA, no IEEE 802.1X)

```
## Shared WEP key connection (no WPA, no IEEE 802.1X) using Shared Key
## IEEE 802.11 authentication
network={
	ssid="static-wep-test2"
	key_mgmt=NONE
	wep_key0="abcde"
	wep_key1=0102030405
	wep_key2="1234567890123"
	wep_tx_keyidx=0
	priority=5
	auth_alg=SHARED
}


```


#### IBSS/ad-hoc network with WPA-None/TKIP.

```
## IBSS/ad-hoc network with WPA-None/TKIP.
network={
	ssid="test adhoc"
	mode=1
	frequency=2412
	proto=WPA
	key_mgmt=WPA-NONE
	pairwise=NONE
	group=TKIP
	psk="secret passphrase"
}


```

#### network可选可写配置项

```
network={
	ssid="example"
	scan_ssid=1
	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
	pairwise=CCMP TKIP
	group=CCMP TKIP WEP104 WEP40
	psk="very secret passphrase"
	eap=TTLS PEAP TLS
	identity="user@example.com"
	password="foobar"
	ca_cert="/etc/cert/ca.pem"
	client_cert="/etc/cert/user.pem"
	private_key="/etc/cert/user.prv"
	private_key_passwd="password"
	phase1="peaplabel=0"
}

```

## /system/etc/wifi/p2p_supplicant.conf

```
disable_scan_offload=1
p2p_no_group_iface=1
persistent_reconnect=1
bss_max_count=400

```



## /data/misc/wifi/WifiConfigStore.xml

```
adb pull /data/misc/wifi/WifiConfigStore.xml

adb push WifiConfigStore.xml /data/misc/wifi/

```


```
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<WifiConfigStoreData>
<int name="Version" value="1" />
<NetworkList>
<Network>
<WifiConfiguration>
<string name="ConfigKey">&quot;D-Link_DIR-816&quot;WPA_PSK</string>
<string name="SSID">&quot;D-Link_DIR-816&quot;</string>
<null name="BSSID" />
<string name="PreSharedKey">&quot;12345678&quot;</string>
<null name="WEPKeys" />
<int name="WEPTxKeyIndex" value="0" />
<boolean name="HiddenSSID" value="false" />
<boolean name="RequirePMF" value="false" />
<byte-array name="AllowedKeyMgmt" num="1">02</byte-array>
<byte-array name="AllowedProtocols" num="1">03</byte-array>
<byte-array name="AllowedAuthAlgos" num="1">01</byte-array>
<byte-array name="AllowedGroupCiphers" num="1">0f</byte-array>
<byte-array name="AllowedPairwiseCiphers" num="1">06</byte-array>
<boolean name="Shared" value="true" />
<boolean name="PreloadedSSID" value="false" />
<int name="SkipAutoConnect" value="0" />
<int name="EapRetryCount" value="0" />
<boolean name="PreloadedForget" value="false" />
<int name="SimSlot" value="0" />
<boolean name="MnMccNetwork" value="false" />
<int name="Status" value="2" />
<null name="FQDN" />
<null name="ProviderFriendlyName" />
<map name="LinkedNetworksList">
<int name="&quot;D-Link_DIR-816_5G&quot;WPA_PSK" value="1" />
</map>
<null name="DefaultGwMacAddress" />
<boolean name="ValidatedInternetAccess" value="true" />
<boolean name="NoInternetAccessExpected" value="false" />
<int name="UserApproved" value="0" />
<boolean name="MeteredHint" value="false" />
<int name="MeteredOverride" value="0" />
<boolean name="UseExternalScores" value="false" />
<int name="NumAssociation" value="4" />
<int name="CreatorUid" value="1000" />
<string name="CreatorName">android.uid.system:1000</string>
<string name="CreationTime">time=03-09 06:39:38.105</string>
<int name="LastUpdateUid" value="1000" />
<string name="LastUpdateName">android.uid.system:1000</string>
<int name="LastConnectUid" value="1000" />
<boolean name="IsLegacyPasspointConfig" value="false" />
<long-array name="RoamingConsortiumOIs" num="0" />
<string name="RandomizedMacAddress">02:00:00:00:00:00</string>
</WifiConfiguration>
<NetworkStatus>
<string name="SelectionStatus">NETWORK_SELECTION_ENABLED</string>
<string name="DisableReason">NETWORK_SELECTION_ENABLE</string>
<string name="ConnectChoice">&quot;open-guest&quot;NONE</string>
<long name="ConnectChoiceTimeStamp" value="1553488933235" />
<boolean name="HasEverConnected" value="true" />
</NetworkStatus>
<IpConfiguration>
<string name="IpAssignment">DHCP</string>
<string name="ProxySettings">NONE</string>
</IpConfiguration>
</Network>

<Network>
<WifiConfiguration>
<string name="ConfigKey">&quot;open-guest&quot;NONE</string>
<string name="SSID">&quot;open-guest&quot;</string>
<null name="BSSID" />
<null name="PreSharedKey" />
<null name="WEPKeys" />
<int name="WEPTxKeyIndex" value="0" />
<boolean name="HiddenSSID" value="false" />
<boolean name="RequirePMF" value="false" />
<byte-array name="AllowedKeyMgmt" num="1">01</byte-array>
<byte-array name="AllowedProtocols" num="1">03</byte-array>
<byte-array name="AllowedAuthAlgos" num="1">01</byte-array>
<byte-array name="AllowedGroupCiphers" num="1">0f</byte-array>
<byte-array name="AllowedPairwiseCiphers" num="1">06</byte-array>
<boolean name="Shared" value="true" />
<boolean name="PreloadedSSID" value="false" />
<int name="SkipAutoConnect" value="0" />
<int name="EapRetryCount" value="0" />
<boolean name="PreloadedForget" value="false" />
<int name="SimSlot" value="0" />
<boolean name="MnMccNetwork" value="false" />
<int name="Status" value="0" />
<null name="FQDN" />
<null name="ProviderFriendlyName" />
<null name="LinkedNetworksList" />
<null name="DefaultGwMacAddress" />
<boolean name="ValidatedInternetAccess" value="false" />
<boolean name="NoInternetAccessExpected" value="false" />
<int name="UserApproved" value="0" />
<boolean name="MeteredHint" value="false" />
<int name="MeteredOverride" value="0" />
<boolean name="UseExternalScores" value="false" />
<int name="NumAssociation" value="3" />
<int name="CreatorUid" value="1000" />
<string name="CreatorName">android.uid.system:1000</string>
<string name="CreationTime">time=03-25 12:11:31.522</string>
<int name="LastUpdateUid" value="1000" />
<string name="LastUpdateName">android.uid.system:1000</string>
<int name="LastConnectUid" value="1000" />
<boolean name="IsLegacyPasspointConfig" value="false" />
<long-array name="RoamingConsortiumOIs" num="0" />
<string name="RandomizedMacAddress">02:00:00:00:00:00</string>
</WifiConfiguration>
<NetworkStatus>
<string name="SelectionStatus">NETWORK_SELECTION_ENABLED</string>
<string name="DisableReason">NETWORK_SELECTION_ENABLE</string>
<null name="ConnectChoice" />
<long name="ConnectChoiceTimeStamp" value="-1" />
<boolean name="HasEverConnected" value="true" />
</NetworkStatus>
<IpConfiguration>
<string name="IpAssignment">DHCP</string>
<string name="ProxySettings">NONE</string>
</IpConfiguration>
</Network>
</NetworkList>
<PasspointConfigData>
<long name="ProviderIndex" value="0" />
</PasspointConfigData>
</WifiConfigStoreData>




```






## /data/misc/wifi/softap.conf

```
adb pull /data/misc/wifi/softap.conf

adb push softap.conf /data/misc/wifi/
```

```
    Hotspot-NAME   
     passwprd       



```
<img src="/public/zimage/wireless/wifi/08_wificonfig/soft.jpg"  />

### 解析 softap.conf 的Java程序

```

package com.company;
import java.io.*;
public class Main {

    public static void main(String[] args) {
        writeToConfigFile();
    }

    public static void loadFromConfigFile() {
        String filename = System.getProperties().getProperty("user.dir") + File.separator+"softap.conf";
        System.out.println("filename =" + filename);
        DataInputStream in = null;
        try {

            if(! new File(filename).exists()){
                System.out.println("softap.conf 并不存在当前工程 无法读取");
                return;
            }

             in = new DataInputStream(new BufferedInputStream(new FileInputStream(filename)));

            int version = in.readInt();
            if ((version != 1) && (version != 2)) {
                System.out.println("version wron");
                System.out.println("version ="+ version);
                return ;
            }
            String SSID = in.readUTF();
            System.out.println("version ="+ version+"          SSID = "+ SSID);

            if (version >= 2) {
                int apBand = in.readInt();
                int apChannel = in.readInt();
                System.out.println("apBand="+ apBand+"        apChannel="+apChannel);
            }
            int authType = in.readInt();
            System.out.println("authType = "+ authType);

            if (authType != 0) {
                String  preSharedKey = in.readUTF();
                System.out.println("preSharedKey = "+ preSharedKey);
            }

            int  hiddenSSID = in.readInt();
            int   max_scb = in.readInt();
            System.out.println("hiddenSSID = "+ hiddenSSID+"         max_scb="+max_scb);
            in.close();
        } catch ( Exception e){

        } finally {

        }
    }
    public static void writeToConfigFile() {
        String ssid="Hotspot-name"; // 【1】[less than 32 size]
        int apBand = 0;   // 【2】[0,1,2]

        int apChannel = 0; //【3】

        //[0(none),1(WPA_PSK),2(WPA_EAP),3(IEEE8021X),4(WPA2_PSK),5(OSEN),6(FT_PSK),7( FT_EAP),8(FT_EAP),9(WPA_EAP_SHA256)]
        int authType = 4; //【4】

        String sharedKey = "password"; //【5】

         boolean hidessid = false ; // 【6】[0,1]

        int max_scb = 10 ; //【7】

        int config_version = 2 ; //【8】
        String filename = System.getProperties().getProperty("user.dir") + File.separator+"softap.conf";
        System.out.println("filename =" + filename);

        try {
            if(! new File(filename).exists()){
                new File(filename).createNewFile();
            }

            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(filename)));
            out.writeInt(config_version);
            out.writeUTF(ssid);
            out.writeInt(apBand);
            out.writeInt(apChannel);
            out.writeInt(authType);
            if (authType != 0) {
                out.writeUTF(sharedKey);
            }
            out.writeInt((hidessid) ? 1 : 0);
            out.writeInt(max_scb);
            out.flush();
            out.close();
        }catch (Exception e){

        }
    }
}


```



## wifi列表数据项

### WifiSettings

```
http://androidxref.com/9.0.0_r3/xref/packages/apps/Settings/src/com/android/settings/wifi/WifiSettings.java

public class WifiSettings extends RestrictedSettingsFragment implements Indexable, WifiTracker.WifiListener, AccessPointListener, WifiDialog.WifiDialogListener 
   
     private WifiEnabler mWifiEnabler;    // WIFI 开关控制类

    // An access point being edited is stored here.
    private AccessPoint mSelectedAccessPoint;   // WIFI列表当前用户选中的网络 AccessPoint
   
     private WifiTracker mWifiTracker;   // AccessPoint 数据来源

    private String mOpenSsid;   // intent的extra 传递的 将要连接的 wifi的 ssid    mOpenSsid = intent.getStringExtra(EXTRA_START_CONNECT_SSID【"wifi_start_connect_ssid"】);

    private PreferenceCategory mAccessPointsPreferenceCategory;   // 显示热点的list容器
    LongPressAccessPointPreference  // 添加 WIFI-Item 的 Preference 布局

    private final Runnable mUpdateAccessPointsRunnable = () -> {  // 执行更新wifi列表的 runnable任务类
        updateAccessPointPreferences();   
    };

   //   由 WifiTracker 排序 并返回 AccessPoints 列表
   List<AccessPoint> accessPoints  = WifiTracker.getAccessPoints();
```

#### updateAccessPointPreferences函数

```
==================
 private void updateAccessPointPreferences() {   // 更新WIFI 列表的函数

   final List<AccessPoint> accessPoints = mWifiTracker.getAccessPoints();

        int index = configureConnectedAccessPointPreferenceCategory(accessPoints) ? 1 : 0;  // 判断是否有正在连接的wifi 得到AccessPoint 显示的起点是 1 还是0 
        int numAccessPoints = accessPoints.size();
        for (; index < numAccessPoints; index++) {
            AccessPoint accessPoint = accessPoints.get(index);
            String key = accessPoint.getKey();
            LongPressAccessPointPreference pref =(LongPressAccessPointPreference) getCachedPreference(key);
            if (pref != null) {
                pref.setOrder(index);
                continue;
            }
             // 如果是新扫描到的 wifi  那么新创建  LongPressAccessPointPreference  Item
            LongPressAccessPointPreference preference =createLongPressAccessPointPreference(accessPoint);
            preference.setKey(key);
            preference.setOrder(index);
           }

            if (mOpenSsid != null && mOpenSsid.equals(accessPoint.getSsidStr()) && accessPoint.getSecurity() != AccessPoint.SECURITY_NONE) {
 // 如果当前将连接的wifi-item 没有保存 或者Disable由于密码错  那么手动触发点击该item
                if (!accessPoint.isSaved() || isDisabledByWrongPassword(accessPoint)) { 
                    onPreferenceTreeClick(preference);
                    mOpenSsid = null;
                }
            }
            mAccessPointsPreferenceCategory.addPreference(preference);
            accessPoint.setListener(WifiSettings.this);
            preference.refresh();
        }

}
==================
```
#### onAccessPointsChanged()

```
/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/WifiTracker.java的接口 WifiListener 实现函数


public class WifiSettings implements  WifiTracker.WifiListener 实现的回调

    /** 当热点AccessPoint 更新时 被回调 ，将刷新wifilist
     * Called to indicate the list of AccessPoints has been updated and
     * getAccessPoints should be called to get the latest information.
     */

    @Override
    public void onAccessPointsChanged() {
        Log.d(TAG, "onAccessPointsChanged (WifiTracker) callback initiated");
        updateAccessPointsDelayed();
    }



    private void updateAccessPointsDelayed() {
        // Safeguard from some delayed event handling
        if (getActivity() != null && !mIsRestricted && mWifiManager.isWifiEnabled()) {
            final View view = getView();
            final Handler handler = view.getHandler();
            if (handler != null && handler.hasCallbacks(mUpdateAccessPointsRunnable)) {
                return;
            }
            setProgressBarVisible(true);
            view.postDelayed(mUpdateAccessPointsRunnable, 300 /* delay milliseconds */);  // mUpdateAccessPointsRunnable 是主函数更新Wifi-list 的 runnable 任务
        }
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/WifiTracker.java#926
   public interface WifiListener {
        /**
         * Called when the state of Wifi has changed, the state will be one of
         * the following.
         *
         * <li>{@link WifiManager#WIFI_STATE_DISABLED}</li>
         * <li>{@link WifiManager#WIFI_STATE_ENABLED}</li>
         * <li>{@link WifiManager#WIFI_STATE_DISABLING}</li>
         * <li>{@link WifiManager#WIFI_STATE_ENABLING}</li>
         * <li>{@link WifiManager#WIFI_STATE_UNKNOWN}</li>
         * <p>
         *
         * @param state The new state of wifi.
         */
        void onWifiStateChanged(int state);

        /**
         * Called when the connection state of wifi has changed and
         * {@link WifiTracker#isConnected()} should be called to get the updated state.
         */
        void onConnectedChanged();

        /**
         * Called to indicate the list of AccessPoints has been updated and
         * {@link WifiTracker#getAccessPoints()} should be called to get the updated list.
         */
        void onAccessPointsChanged();
    }


```


### WifiTracker

```
http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/WifiTracker.java

public class WifiTracker implements LifecycleObserver, OnStart, OnStop, OnDestroy   {

  private final WifiListenerExecutor mListener;  // 接口的调用执行类

    // 构造函数
    public WifiTracker(Context context, WifiListener wifiListener, @NonNull Lifecycle lifecycle, boolean includeSaved, boolean includeScans) {
                this(context, wifiListener,
                context.getSystemService(WifiManager.class),
                context.getSystemService(ConnectivityManager.class),
                context.getSystemService(NetworkScoreManager.class),
                newIntentFilter());

   WifiTracker(Context context, WifiListener wifiListener,
            WifiManager wifiManager, ConnectivityManager connectivityManager,
            NetworkScoreManager networkScoreManager,
            IntentFilter filter) {
        mContext = context;
        mWifiManager = wifiManager;
        mListener = new WifiListenerExecutor(wifiListener);  // 把 【wifiListener&&WifiSettings】封装到  WifiListenerExecutor 中
  }
}


构造函数调用位置:
http://androidxref.com/9.0.0_r3/xref/packages/apps/Settings/src/com/android/settings/wifi/WifiSettings.java#242
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        mWifiTracker = WifiTrackerFactory.create(getActivity(), this【wifiListener&&WifiSettings】, getLifecycle(), true, true);
}

```


#### WifiListenerExecutor接口回调执行内部类

```
   @VisibleForTesting class WifiListenerExecutor implements WifiListener {

        private final WifiListener mDelegatee;  //【WifiSettings】   在这里接口实现会被调用

        public WifiListenerExecutor(WifiListener listener) {
            mDelegatee = listener;
        }

        @Override
        public void onWifiStateChanged(int state) {
            runAndLog(() -> mDelegatee.onWifiStateChanged(state),
                    String.format("Invoking onWifiStateChanged callback with state %d", state));
        }

        @Override
        public void onConnectedChanged() {
            runAndLog(mDelegatee::onConnectedChanged, "Invoking onConnectedChanged callback");
        }

        @Override
        public void onAccessPointsChanged() {
            runAndLog(mDelegatee::onAccessPointsChanged, "Invoking onAccessPointsChanged callback");
        }

        private void runAndLog(Runnable r, String verboseLog) {
            ThreadUtils.postOnMainThread(() -> {
                if (mRegistered) {
                    if (isVerboseLoggingEnabled()) {
                        Log.i(TAG, verboseLog);
                    }
                    r.run();
                }
            });
        }
    }


```

#### WifiListener接口

```

    public interface WifiListener {
        /**
         * Called when the state of Wifi has changed, the state will be one of
         * the following.
         *
         * <li>{@link WifiManager#WIFI_STATE_DISABLED}</li>
         * <li>{@link WifiManager#WIFI_STATE_ENABLED}</li>
         * <li>{@link WifiManager#WIFI_STATE_DISABLING}</li>
         * <li>{@link WifiManager#WIFI_STATE_ENABLING}</li>
         * <li>{@link WifiManager#WIFI_STATE_UNKNOWN}</li>
         * <p>
         *
         * @param state The new state of wifi.
         */
        void onWifiStateChanged(int state);

        /**
         * Called when the connection state of wifi has changed and
         * {@link WifiTracker#isConnected()} should be called to get the updated state.
         */
        void onConnectedChanged();

        /**
         * Called to indicate the list of AccessPoints has been updated and
         * {@link WifiTracker#getAccessPoints()} should be called to get the updated list.
         */
        void onAccessPointsChanged();
    }


```


#### conditionallyNotifyListeners()执行热点更新函数

```




    private void conditionallyNotifyListeners() {
        if (mStaleScanResults) {
            return;
        }

        mListener.onAccessPointsChanged();
    }


执行热点更新函数 conditionallyNotifyListeners() 被调用位置:
    /** Update the internal list of access points. */   感觉像是 ScanResult 和 WifiConfiguration 配对生成AccessPoint
    private void updateAccessPoints【1】(final List<ScanResult> newScanResults, List<WifiConfiguration> configs) {

  conditionallyNotifyListeners();
}


    private void updateNetworkInfo【2】(NetworkInfo networkInfo) {
     if (updated) {
                conditionallyNotifyListeners();
            }
}


  private void clearAccessPointsAndConditionallyUpdate【3】() {  // 清除 accessPoint 
     conditionallyNotifyListeners();
}


private void updateNetworkScores【4】() {  // 更新热点分数时  执行回调更新 wifi-list
    if (updated) {
        Collections.sort(mInternalAccessPoints);
        conditionallyNotifyListeners();
    }
}



```

#### updateAccessPoints() framework层面更新Accesspoint函数

```
    private WifiInfo mLastInfo;   // 最近连接上的 WIFIInfo 基数据
    private final List<AccessPoint> mInternalAccessPoints = new ArrayList<>();  // 当前已经保存的 AccessPoint 列表
    private final Set<NetworkKey> mRequestedScores = new ArraySet<>();




 http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/WifiTracker.java#518
    private void updateAccessPoints(final List<ScanResult> newScanResults,List<WifiConfiguration> configs) {    /** Update the internal list of access points. */
//    List<WifiConfiguration> configs来源【8】 
        // Map configs and scan results necessary to make AccessPoints
        final Map<String, WifiConfiguration> configsByKey = new ArrayMap(configs.size());  // 创建  Map<String, WifiConfiguration>  ssid与WifiConfiguration 一一对应起来?
        if (configs != null) {
            for (WifiConfiguration config : configs) {
 //   key[ssid,1   ssid,2  ssid,3   ssid,4  ]    添加key 与  value
                configsByKey.put(AccessPoint.getKey(config), config); 【1】
            }
        }

// 获得  key[ssid,1] value[ List<ScanResult> ] 的Map value中含有相同的key的 ScanResult 
        ArrayMap<String, List<ScanResult>> scanResultsByApKey = updateScanResultCache(newScanResults); 【2】

        WifiConfiguration connectionConfig = null;
        if (mLastInfo != null) {  // 如果当前有连接的 WIFI的话  那么得到这个已连接Wifi的  WifiConfiguration
            connectionConfig = getWifiConfigurationForNetworkId(mLastInfo.getNetworkId(), configs);
        }

        // Rather than dropping and reacquiring the lock multiple times in this method, we lock
        // once for efficiency of lock acquisition time and readability
        synchronized (mLock) {
            // Swap the current access points into a cached list for maintaining AP listeners
            List<AccessPoint> cachedAccessPoints;

// private final List<AccessPoint> mInternalAccessPoints = new ArrayList<>();  复制一份当前的 mInternalAccessPoints 
            cachedAccessPoints = new ArrayList<>(mInternalAccessPoints);  

            ArrayList<AccessPoint> accessPoints = new ArrayList<>();

            final List<NetworkKey> scoresToRequest = new ArrayList<>();


//   ArrayMap<String, List<ScanResult>>   遍历 Key  Value
            for (Map.Entry<String, List<ScanResult>> entry : scanResultsByApKey.entrySet()) {

                for (ScanResult result : entry.getValue()) { //  遍历  List<ScanResult>>
                    NetworkKey key = NetworkKey.createFromScanResult(result);    【3】// 依据 ScanResult 创建  NetworkKey
                    if (key != null && !mRequestedScores.contains(key)) { 如果Set<NetworkKey>  不包含 当前NetworkKey-Item 那么 添加它
                        scoresToRequest.add(key);   // Set<NetworkKey> mRequestedScores 
                    }
                }
// 找到或者从List<AccessPoint>cachedAccessPoints  对应 与 ScanResult.key  相同的 那么 AccessPoint 
                AccessPoint accessPoint = getCachedOrCreate(entry.getValue(), cachedAccessPoints);  【4】
                if (mLastInfo != null && mLastNetworkInfo != null) {
                    accessPoint.update(connectionConfig, mLastInfo, mLastNetworkInfo);    【5】 // 如果当前有连接wifi   那么更新当前 accessPoint
                }

                // Update the matching config if there is one, to populate saved network info
                 //  更新 accessPoint 的  networkId  ,  Map<String, WifiConfiguration>
                accessPoint.update(configsByKey.get(entry.getKey())【WifiConfiguration】); 【5】 ▲    

                accessPoints.add(accessPoint);   // 更新过后的 AccessPoint 放入    ArrayList<AccessPoint> accessPoints
            }

            // If there were no scan results, create an AP for the currently connected network (if
            // it exists).
            // TODO(b/b/73076869): Add support for passpoint (ephemeral) networks
 // 如果当前 更新完成后的  ArrayList<AccessPoint> accessPoints为空  但连接了wifi 有 connectionConfig
//  可能是零时网络  passpoint 网络
            if (accessPoints.isEmpty() && connectionConfig != null) { 
                AccessPoint activeAp = new AccessPoint(mContext, connectionConfig);
                activeAp.update(connectionConfig, mLastInfo, mLastNetworkInfo);
                accessPoints.add(activeAp);
                scoresToRequest.add(NetworkKey.createFromWifiInfo(mLastInfo));
            }

            requestScoresForNetworkKeys(scoresToRequest);  //  【6】请求 对 List<NetworkKey> scoresToRequest  进行评分
            for (AccessPoint ap : accessPoints) {   
//  WifiNetworkScoreCache mScoreCache;
// mNetworkScoringUiEnabled =Settings.Global.getInt(mContext.getContentResolver(),  Settings.Global.NETWORK_SCORING_UI_ENABLED, 0) == 1; 
// mMaxSpeedLabelScoreCacheAge =  Settings.Global.getLong( mContext.getContentResolver(),Settings.Global.SPEED_LABEL_CACHE_EVICTION_AGE_MILLIS,  DEFAULT_MAX_CACHED_SCORE_AGE_MILLIS);
// private static final long DEFAULT_MAX_CACHED_SCORE_AGE_MILLIS = 20 * DateUtils.MINUTE_IN_MILLIS;    // 120 

                ap.update(mScoreCache, mNetworkScoringUiEnabled, mMaxSpeedLabelScoreCacheAge);  【5】 继续执行 AccessPoint的 update 方法
            }

            // Pre-sort accessPoints to speed preference insertion
            Collections.sort(accessPoints);      【6】 对accessPoints 进行排序

            // Log accesspoints that are being removed
            if (DBG()) {  // 打印的Log信息
                Log.d(TAG, "------ Dumping SSIDs that were not seen on this scan ------");
                for (AccessPoint prevAccessPoint : mInternalAccessPoints) {
                    if (prevAccessPoint.getSsid() == null)
                        continue;
                    String prevSsid = prevAccessPoint.getSsidStr();
                    boolean found = false;
                    for (AccessPoint newAccessPoint : accessPoints) {
                        if (newAccessPoint.getSsidStr() != null && newAccessPoint.getSsidStr().equals(prevSsid)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        Log.d(TAG, "Did not find " + prevSsid + " in this scan");
                }
                Log.d(TAG, "---- Done dumping SSIDs that were not seen on this scan ----");
            }

            mInternalAccessPoints.clear();  // 保存当前过滤好的  List<AccessPoint> 
            mInternalAccessPoints.addAll(accessPoints);
        }

        conditionallyNotifyListeners();   // 调用更新方法  进行回调更新
    }


```

##### Accesspoint.getkey()

```
http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java#589
    public static String getKey(ScanResult result) {  //  返回 ssid,1   ssid,2  ssid,3   ssid,4  作为Map<Key,WifiConfiguration> 的 key 
        StringBuilder builder = new StringBuilder();

        if (TextUtils.isEmpty(result.SSID)) {
            builder.append(result.BSSID);
        } else {
            builder.append(result.SSID);
        }

        builder.append(',').append(getSecurity(result));
        return builder.toString();
    }

    public static String getKey(WifiConfiguration config) {
        StringBuilder builder = new StringBuilder();

        if (TextUtils.isEmpty(config.SSID)) {
            builder.append(config.BSSID);
        } else {
            builder.append(removeDoubleQuotes(config.SSID));
        }

        builder.append(',').append(getSecurity(config));
        return builder.toString();
    }

    public static final int SECURITY_NONE = 0;
    public static final int SECURITY_WEP = 1;
    public static final int SECURITY_PSK = 2;
    public static final int SECURITY_EAP = 3;

    private static final int PSK_UNKNOWN = 0;
    private static final int PSK_WPA = 1;
    private static final int PSK_WPA2 = 2;
    private static final int PSK_WPA_WPA2 = 3;


    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains("WEP")) {
            return SECURITY_WEP; 【1】
        } else if (result.capabilities.contains("PSK")) {
            return SECURITY_PSK;【2】
        } else if (result.capabilities.contains("EAP")) {
            return SECURITY_EAP;【3】
        }
        return SECURITY_NONE;【0】
    }

    static int getSecurity(WifiConfiguration config) {
        if (config.allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
            return SECURITY_PSK;【2】
        }
        if (config.allowedKeyManagement.get(KeyMgmt.WPA_EAP) ||
                config.allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            return SECURITY_EAP;【3】
        }
        return (config.wepKeys[0] != null) ? SECURITY_WEP【1】 : SECURITY_NONE【0】;
    }



```

##### updateScanResultCache

```
http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/WifiTracker.java#434

    // Does not need to be locked as it only updated on the worker thread, with the exception of
    // during onStart, which occurs before the receiver is registered on the work handler.

    private final HashMap<String, ScanResult> mScanResultCache = new HashMap<>();


    private ArrayMap<String, List<ScanResult>> updateScanResultCache(final List<ScanResult> newResults) {
        // TODO(sghuman): Delete this and replace it with the Map of Ap Keys to ScanResults for memory efficiency
        // 删除此项并将其替换为扫描结果的AP键映射以提高内存效率

        for (ScanResult newResult : newResults) { // 检查 List<ScanResult> 中的 ScanResult的 ssid 是否为空
            if (newResult.SSID == null || newResult.SSID.isEmpty()) {
                continue;
            }
            mScanResultCache.put(newResult.BSSID, newResult);  // ScanResult的 ssid 不为空就放入到  HashMap<String, ScanResult> mScanResultCache Map中
        }

        // Don't evict old results if no new scan results
        if (!mStaleScanResults) {
            evictOldScans();
        }

        ArrayMap<String, List<ScanResult>> scanResultsByApKey = new ArrayMap<>();    // 创建新的 ArrayMap<String, List<ScanResult>>  一个热点名 对应多个bssid的情况
        for (ScanResult result : mScanResultCache.values()) {   //   HashMap<String, ScanResult> mScanResultCache  遍历Map中的Value 每一个 ScanResult
            // Ignore hidden and ad-hoc networks.   IBSS貌似是 P2P组网的网络   // 对于那些 SSID为空  或者 Capabilities 中显示IBSS (独立组网 P2P)的网络 过滤掉
            if (result.SSID == null || result.SSID.length() == 0 || result.capabilities.contains("[IBSS]")) {
                continue;
            }  

            String apKey = AccessPoint.getKey(result);  //  key[ssid,1   ssid,2  ssid,3   ssid,4  ]   获得key字符串
            List<ScanResult> resultList;
            if (scanResultsByApKey.containsKey(apKey)) {    // 如果之前创建的   ArrayMap<String, List<ScanResult>> 包含 apKey  那么就依据 key 得到 List<ScanResult> 
                resultList = scanResultsByApKey.get(apKey);
            } else {
                resultList = new ArrayList<>();
                scanResultsByApKey.put(apKey, resultList);   // 否则 就创建新的  new ArrayList<>  ,  <key,ArrayList<>>  放入到 map 中
            }

            resultList.add(result);    //  把当前的 result 放入到    List<ScanResult>  ， 这样保证了 这个  List<ScanResult> 含有相同的 ssid,1 key  名称相同
        }

        return scanResultsByApKey;
    }
```


##### createFromScanResult

```
http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/net/NetworkKey.java#70

1. 依据  ScanResult 的 ssid 和 bssid  创建 WifiKey
2. 依据WifiKey  创建  NetworkKey
   /**
     * Constructs a new NetworkKey for the given wifi {@link ScanResult}.
     *
     * @return  A new {@link NetworkKey} instance or <code>null</code> if the given
     *          {@link ScanResult} instance is malformed.
     * @hide
     */
    @Nullable
    public static NetworkKey createFromScanResult(@Nullable ScanResult result) {
        if (result != null && result.wifiSsid != null) {
            final String ssid = result.wifiSsid.toString();
            final String bssid = result.BSSID;
            if (!TextUtils.isEmpty(ssid) && !ssid.equals(WifiSsid.NONE) && !TextUtils.isEmpty(bssid)) {
                WifiKey wifiKey;
                try {
                    wifiKey = new WifiKey(String.format("\"%s\"", ssid), bssid);
                } catch (IllegalArgumentException e) {
                    Log.e(TAG, "Unable to create WifiKey.", e);
                    return null;
                }
                return new NetworkKey(wifiKey);
            }
        }
        return null;
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/net/WifiKey.java#66
public class WifiKey implements Parcelable {

    public WifiKey(String ssid, String bssid) {
        if (ssid == null || !SSID_PATTERN.matcher(ssid).matches()) {
            throw new IllegalArgumentException("Invalid ssid: " + ssid);
        }
        if (bssid == null || !BSSID_PATTERN.matcher(bssid).matches()) {
            throw new IllegalArgumentException("Invalid bssid: " + bssid);
        }
        this.ssid = ssid;
        this.bssid = bssid;
    }



http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/net/NetworkKey.java#121
public class NetworkKey implements Parcelable {
    public NetworkKey(WifiKey wifiKey) {
        this.type = TYPE_WIFI;
        this.wifiKey = wifiKey;
    }


```


##### getCachedOrCreate


```
    AccessPoint getCachedOrCreate(List<ScanResult> scanResults, List<AccessPoint> cache) {
        final int N = cache.size();
        for (int i = 0; i < N; i++) {
//   List<ScanResult> 中的 ScanResult.getKey是相同的
//从 List<AccessPoint> 中遍历找到那个 与  ScanResult.getKey 相同的 那个 AccessPoint-Item ,
// 然后设置这个  AccessPoint 的 scanresult 并从 List<ScanResult>  cache 删除它 (因为它完成了配置)
            if (cache.get(i).getKey().equals(AccessPoint.getKey(scanResults.get(0)))) {
                AccessPoint ret = cache.remove(i);
                ret.setScanResults(scanResults);
                return ret;
            }
        }
        final AccessPoint accessPoint = new AccessPoint(mContext, scanResults);  // 如果找不到 scanResult.key 相同的 AccessPoint  那么就新建这样的 AccessPoint
        return accessPoint;
    }



```



##### accessPoint.update

```
http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java#1086

    /** Attempt to update the AccessPoint and return true if an update occurred. */
    public boolean update( @Nullable WifiConfiguration config, WifiInfo info, NetworkInfo networkInfo) {

        boolean updated = false;
        final int oldLevel = getLevel();
        if (info != null && isInfoForThisAccessPoint(config, info)) {
            updated = (mInfo == null);
            if (mConfig != config) {
                // We do not set updated = true as we do not want to increase the amount of sorting
                // and copying performed in WifiTracker at this time. If issues involving refresh
                // are still seen, we will investigate further.
                update(config); // Notifies the AccessPointListener of the change  更新配置文件
            }
            if (mRssi != info.getRssi() && info.getRssi() != WifiInfo.INVALID_RSSI) {
                mRssi = info.getRssi();
                updated = true;
            } else if (mNetworkInfo != null && networkInfo != null && mNetworkInfo.getDetailedState() != networkInfo.getDetailedState()) {
                updated = true;
            }
            mInfo = info;
            mNetworkInfo = networkInfo;
        } else if (mInfo != null) {
            updated = true;
            mInfo = null;
            mNetworkInfo = null;
        }
        if (updated && mAccessPointListener != null) {
            ThreadUtils.postOnMainThread(() -> {
                if (mAccessPointListener != null) {
                    mAccessPointListener.onAccessPointChanged(this);  // 回调 onAccessPointChanged
                }
            });

            if (oldLevel != getLevel() /* current level */) {
                ThreadUtils.postOnMainThread(() -> {
                    if (mAccessPointListener != null) {
                        mAccessPointListener.onLevelChanged(this);   // 回调 onLevelChanged
                    }
                });
            }
        }

        return updated;
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java#1133
    void update(@Nullable WifiConfiguration config) {
        mConfig = config;
        networkId = config != null ? config.networkId : WifiConfiguration.INVALID_NETWORK_ID;  // ▲ WifiConfiguration 为空导致  networkId 等于 -1 
        ThreadUtils.postOnMainThread(() -> {
            if (mAccessPointListener != null) {
                mAccessPointListener.onAccessPointChanged(this);
            }
        });
    }



http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java#464
  boolean update(WifiNetworkScoreCache scoreCache, boolean scoringUiEnabled, long maxScoreCacheAgeMillis) {
        boolean scoreChanged = false;
        if (scoringUiEnabled) {  // 如果要显示 分数
            scoreChanged = updateScores(scoreCache, maxScoreCacheAgeMillis);
        }
        return updateMetered(scoreCache) || scoreChanged;
    }


    /**
     * Updates the AccessPoint's metering based on {@link ScoredNetwork#meteredHint}, returning
     * true if the metering changed.
     */
    private boolean updateMetered(WifiNetworkScoreCache scoreCache) {
        boolean oldMetering = mIsScoredNetworkMetered;
        mIsScoredNetworkMetered = false;

        if (isActive() && mInfo != null) {
            NetworkKey key = NetworkKey.createFromWifiInfo(mInfo);
            ScoredNetwork score = scoreCache.getScoredNetwork(key);
            if (score != null) {
                mIsScoredNetworkMetered |= score.meteredHint;
            }
        } else {
            for (ScanResult result : mScanResults) {
                ScoredNetwork score = scoreCache.getScoredNetwork(result);
                if (score == null) {
                    continue;
                }
                mIsScoredNetworkMetered |= score.meteredHint;
            }
        }
        return oldMetering == mIsScoredNetworkMetered;
    }


```


##### requestScoresForNetworkKeys(scoresToRequest) 热点评分方法

```
http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/WifiTracker.java#343

private final Set<NetworkKey> mRequestedScores = new ArraySet<>();  // 全局
 final List<NetworkKey> scoresToRequest  // 局部
    private void requestScoresForNetworkKeys(Collection<NetworkKey> keys) {
        if (keys.isEmpty()) return;

        if (DBG()) {
            Log.d(TAG, "Requesting scores for Network Keys: " + keys);
        }
        mNetworkScoreManager.requestScores(keys.toArray(new NetworkKey[keys.size()])); // 调用 mNetworkScoreManager 对  NetworkKey 进行评分处理
        synchronized (mLock) {
            mRequestedScores.addAll(keys);
        }
    }


```


##### Collections.sort(accessPoints)  热点排序实现

```

Collections.sort(accessPoints)

http://androidxref.com/9.0.0_r3/xref/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java#81


public class AccessPoint implements Comparable<AccessPoint> {

compareTo(T o)  函数的实现


}




    /**
    * Returns a negative integer, zero, or a positive integer if this AccessPoint is less than,
    * equal to, or greater than the other AccessPoint.
    *
    * Sort order rules for AccessPoints:
    *   1. Active before inactive
    *   2. Reachable before unreachable
    *   3. Saved before unsaved
    *   4. Network speed value
    *   5. Stronger signal before weaker signal
    *   6. SSID alphabetically
    *
1. 有用的在没用的之前
2.可达的在不可达的之前
3.以保存的在未保存的之前
4.依据网络速度靠先
5.信号强度靠前
6.SSID 按字母顺序排列

    * Note that AccessPoints with a signal are usually also Reachable,
    * and will thus appear before unreachable saved AccessPoints.
    */
    @Override
    public int compareTo(@NonNull AccessPoint other) {
        // Active one goes first.
        if (isActive() && !other.isActive()) return -1;
        if (!isActive() && other.isActive()) return 1;

        // Reachable one goes before unreachable one.
        if (isReachable() && !other.isReachable()) return -1;
        if (!isReachable() && other.isReachable()) return 1;

        // Configured (saved) one goes before unconfigured one.
        if (isSaved() && !other.isSaved()) return -1;
        if (!isSaved() && other.isSaved()) return 1;

        // Faster speeds go before slower speeds - but only if visible change in speed label
        if (getSpeed() != other.getSpeed()) {
            return other.getSpeed() - getSpeed();
        }

        // Sort by signal strength, bucketed by level
        int difference = WifiManager.calculateSignalLevel(other.mRssi, SIGNAL_LEVELS)
                - WifiManager.calculateSignalLevel(mRssi, SIGNAL_LEVELS);
        if (difference != 0) {
            return difference;
        }

        // Sort by ssid.
        difference = getSsidStr().compareToIgnoreCase(other.getSsidStr());
        if (difference != 0) {
            return difference;
        }

        // Do a case sensitive comparison to distinguish SSIDs that differ in case only
        return getSsidStr().compareTo(other.getSsidStr());
    }

```


##### configsByKey List<WifiConfiguration> configs数据来源分析

```
List<WifiConfiguration> configs
Map<String, WifiConfiguration> configsByKey 

    private void updateAccessPoints(final List<ScanResult> newScanResults,List<WifiConfiguration> configs) { }   该方法被调用处




    private void fetchScansAndConfigsAndUpdateAccessPoints() {
        final List<ScanResult> newScanResults = mWifiManager.getScanResults();
        if (isVerboseLoggingEnabled()) {
            Log.i(TAG, "Fetched scan results: " + newScanResults);
        }

        List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();  //    List<WifiConfiguration> 来源于 WifiManager
        updateAccessPoints(newScanResults, configs);    【调用方法】
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/base/wifi/java/android/net/wifi/WifiManager.java#1016

    /**
     * Return a list of all the networks configured for the current foreground
     * user.
     * Not all fields of WifiConfiguration are returned. Only the following
     * fields are filled in:
     * <ul>
     * <li>networkId</li>
     * <li>SSID</li>
     * <li>BSSID</li>
     * <li>priority</li>
     * <li>allowedProtocols</li>
     * <li>allowedKeyManagement</li>
     * <li>allowedAuthAlgorithms</li>
     * <li>allowedPairwiseCiphers</li>
     * <li>allowedGroupCiphers</li>
     * </ul>
     * @return a list of network configurations in the form of a list
     * of {@link WifiConfiguration} objects.
     */
    public List<WifiConfiguration> getConfiguredNetworks() {
        try {
            ParceledListSlice<WifiConfiguration> parceledList = mService.getConfiguredNetworks();
            if (parceledList == null) {
                return Collections.emptyList();
            }
            return parceledList.getList();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java#1738

    /**
     * see {@link android.net.wifi.WifiManager#getConfiguredNetworks()}
     * @return the list of configured networks
     */
    @Override
    public ParceledListSlice<WifiConfiguration> getConfiguredNetworks() {
        enforceAccessPermission();
        if (mVerboseLoggingEnabled) {
            mLog.info("getConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
        }
        if (mWifiStateMachineChannel != null) {
            List<WifiConfiguration> configs = mWifiStateMachine.syncGetConfiguredNetworks( Binder.getCallingUid(), mWifiStateMachineChannel);
            if (configs != null) {
                return new ParceledListSlice<WifiConfiguration>(configs);
            }
        } else {
            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        }
        return null;
    }



http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java#1578

    public List<WifiConfiguration> syncGetConfiguredNetworks(int uuid, AsyncChannel channel) {
        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_CONFIGURED_NETWORKS, uuid);
        if (resultMsg == null) { // an error has occurred
            return null;
        } else {
            List<WifiConfiguration> result = (List<WifiConfiguration>) resultMsg.obj;
            resultMsg.recycle();
            return result;
        }
    }

http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java#3323
    class DefaultState extends State {

        @Override
        public boolean processMessage(Message message) {
            logStateAndMessage(message, this);

            switch (message.what) {
                case CMD_GET_CONFIGURED_NETWORKS:
                    replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
                    break;
        .....

}



http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigManager.java#511
    public List<WifiConfiguration> getSavedNetworks() {
        return getConfiguredNetworks(true, true);
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigManager.java#472
    private List<WifiConfiguration> getConfiguredNetworks( boolean savedOnly, boolean maskPasswords) {
        List<WifiConfiguration> networks = new ArrayList<>();
        for (WifiConfiguration config : getInternalConfiguredNetworks()) {
            if (savedOnly && config.ephemeral) {
                continue;
            }
            networks.add(createExternalWifiConfiguration(config, maskPasswords));
        }
        return networks;
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigManager.java#591
    private Collection<WifiConfiguration> getInternalConfiguredNetworks() {
        return mConfiguredNetworks.valuesForCurrentUser();
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigManager.java#260
    /**
     * Map of configured networks with network id as the key.  保存所有WiFiConfiguration 的类
     */
    private final ConfigurationMap mConfiguredNetworks;




    private NetworkUpdateResult addOrUpdateNetworkInternal(WifiConfiguration config, int uid) {
        if (mVerboseLoggingEnabled) {
            Log.v(TAG, "Adding/Updating network " + config.getPrintableSsid());
        }
        WifiConfiguration newInternalConfig = null;
        mConfiguredNetworks.put(newInternalConfig);    // 新增 WiFiConfiguration 
}




http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigManager.java#2790
  public boolean loadFromStore() {
        loadInternalData(mNetworkListStoreData.getSharedConfigurations(), mNetworkListStoreData.getUserConfigurations(),mDeletedEphemeralSsidsStoreData.getSsidList());

}

    private void loadInternalData(List<WifiConfiguration> sharedConfigurations,List<WifiConfiguration> userConfigurations, Set<String> deletedEphemeralSSIDs) {
。。。。
           mWifiConfigStore.read();
          loadInternalDataFromSharedStore(sharedConfigurations);
。。。。
}


    private void loadInternalDataFromSharedStore( List<WifiConfiguration> configurations) {
        for (WifiConfiguration configuration : configurations) {
            configuration.networkId = mNextNetworkId++;
            if (mVerboseLoggingEnabled) {
                Log.v(TAG, "Adding network from shared store " + configuration.configKey());
            }
            try {
                mConfiguredNetworks.put(configuration);   // 加载配置
            } catch (IllegalArgumentException e) {
                Log.e(TAG, "Failed to add network to config map", e);
            }
        }
    }


http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiInjector.java#212
        mWifiConfigStore = new WifiConfigStore(mContext, wifiStateMachineLooper, mClock,WifiConfigStore.createSharedFile());



http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigStore.java#345

    public WifiConfigStore(Context context, Looper looper, Clock clock,StoreFile sharedStore) {
        // Initialize the store files.
        mSharedStore = sharedStore;

}

    public static StoreFile createSharedFile() {
        return createFile(Environment.getDataMiscDirectory());
    }

    /**
     * Helper method to create a store file instance for either the shared store or user store.
     * Note: The method creates the store directory if not already present. This may be needed for
     * user store files.
     *
     * @param storeBaseDir Base directory under which the store file is to be stored. The store file
     *                     will be at <storeBaseDir>/wifi/WifiConfigStore.xml.
     * @return new instance of the store file.
     */
    private static StoreFile createFile(File storeBaseDir) {
        File storeDir = new File(storeBaseDir, STORE_DIRECTORY_NAME);
        if (!storeDir.exists()) {
            if (!storeDir.mkdir()) {
                Log.w(TAG, "Could not create store directory " + storeDir);
            }
        }
        return new StoreFile(new File(storeDir, STORE_FILE_NAME 【 "WifiConfigStore.xml" 】));  // /data/misc/wifi/WifiConfigStore.xml 
    }






    /**
     * API to read the store data from the config stores.
     * The method reads the user specific configurations from user specific config store and the
     * shared configurations from the shared config store.
     */
    public void read() throws XmlPullParserException, IOException {
        // Reset both share and user store data.
        resetStoreData(true);
        if (mUserStore != null) {
            resetStoreData(false);
        }

        long readStartTime = mClock.getElapsedSinceBootMillis();
        byte[] sharedDataBytes = mSharedStore.readRawData();
        byte[] userDataBytes = null;
        if (mUserStore != null) {
            userDataBytes = mUserStore.readRawData();
        }
        long readTime = mClock.getElapsedSinceBootMillis() - readStartTime;
        Log.d(TAG, "Reading from stores completed in " + readTime + " ms.");
        deserializeData(sharedDataBytes, true);
        if (mUserStore != null) {
            deserializeData(userDataBytes, false);
        }
    }

http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigStore.java#472
  private StoreFile mSharedStore;

  public static class StoreFile {
   private String mFileName;

   private final AtomicFile mAtomicFile;
}



http://androidxref.com/9.0.0_r3/xref/frameworks/opt/net/wifi/service/java/com/android/server/wifi/ConfigurationMap.java
public class ConfigurationMap { ▲   WifiConfiguration 存储位置 

    private final Map<Integer, WifiConfiguration> mPerID = new HashMap<>();
    private final Map<Integer, WifiConfiguration> mPerIDForCurrentUser = new HashMap<>();
    private final Map<ScanResultMatchInfo, WifiConfiguration>  mScanResultMatchInfoMapForCurrentUser = new HashMap<>();


    public WifiConfiguration put(WifiConfiguration config) {  // 新增
        final WifiConfiguration current = mPerID.put(config.networkId, config);
        if (WifiConfigurationUtil.isVisibleToAnyProfile(config,mUserManager.getProfiles(mCurrentUserId))) {

            mPerIDForCurrentUser.put(config.networkId, config);
            mScanResultMatchInfoMapForCurrentUser.put(ScanResultMatchInfo.fromWifiConfiguration(config), config);

        }
        return current;
    }


    public WifiConfiguration remove(int netID) {   // 删除
        WifiConfiguration config = mPerID.remove(netID);
        if (config == null) {
            return null;
        }

        mPerIDForCurrentUser.remove(netID);

        Iterator<Map.Entry<ScanResultMatchInfo, WifiConfiguration>> scanResultMatchInfoEntries = mScanResultMatchInfoMapForCurrentUser.entrySet().iterator();
        while (scanResultMatchInfoEntries.hasNext()) {
            if (scanResultMatchInfoEntries.next().getValue().networkId == netID) {
                scanResultMatchInfoEntries.remove();
                break;
            }
        }
        return config;
    }


}




```


## /system/build.prop
```
adb pull /system/build.prop .
adb push ./build.prop  /system/



```

## 路径(wifi详情)

```

1 . Setting > Network & internet > Wi-fi [toogle close] 
2. Setting > Network & internet > Wi-fi > Wi-Fi preferences > Turn on Wi-fi automatically [toogle close] 
3. Setting > Network & internet > Wi-fi > Wi-Fi preferences > open network notification [toogle close] 

tap 5 time at Settings > System > About pone > Build number
4. Setting > System > Advanced > Developer options >Enable WiFi Verbose Logging  [toogle open] 

5. Setting > Security & location > Location(Privacy) > Advance > Scanning >  Wi-Fi scanning[toogle close] 
6. Setting > Security & location > Location(Privacy) > Advance > Scanning >  Bluetooth scanning[toogle close]

```
