---
layout: post
title: 代码区块
category: 代码
tags: 代码
keywords: 代码  
typora-root-url: ..\..\
typora-copy-images-to: ..\..\public\zimage
---

## 2_简介
 * TOC
 {:toc}
 
## 2_代码区块


### 3_String字符串操作


#### 4_强制转换整型

##### 5_Rust

```

fn main() {
   let penguin_data = "\
   common name  ,length (cm)
   Little penguin  ,   33
   Yellow-eyed penguin  ,   65
   Fiordland penguin,  60
   Invalid,data
   ";

   let records = penguin_data.lines();  //  这里返回的行的迭代器 iteration  

   for (i, record) in records.enumerate() {   // iteration 只能读取到value , 不能读取到索引  ,  iteration.enumerate() 就能读取到索引以及对应的value
     if i == 0 || record.trim().len() == 0 {  // i ==0 把 第一行  common name  ,length (cm) 过滤掉了
       continue;
     }

     // 声明一个 fields 变量，类型是 Vec
     // Vec 是 vector 的缩写，是一个可伸缩的集合类型，可以认为是一个动态数组
     // <_>表示 Vec 中的元素类型由编译器自行推断，在很多场景下，都会帮我们省却不少功夫
     let fields: Vec<_> = record
       .split(',')
       .map(|field| field.trim())
       .collect();
     if cfg!(debug_assertions) {
         // 输出到标准错误输出
       //   eprintln!("debug: {:?} -> {:?}", record, fields);
     }

     let name = fields[0];
     // 1. 尝试把 fields[1] 的值转换为 f32 类型的浮点数，如果成功，则把 f32 值赋给 length 变量
     //
     // 2. if let 是一个匹配表达式，用来从=右边的结果中，匹配出 length 的值：
     //   1）当=右边的表达式执行成功，则会返回一个 Ok(f32) 的类型，若失败，则会返回一个 Err(e) 类型，if let 的作用就是仅匹配 Ok 也就是成功的情况，如果是错误，就直接忽略
     //   2）同时 if let 还会做一次解构匹配，通过 Ok(length) 去匹配右边的 Ok(f32)，最终把相应的 f32 值赋给 length
     //
     // 3. 当然你也可以忽略成功的情况，用 if let Err(e) = fields[1].parse::<f32>() {...}匹配出错误，然后打印出来，但是没啥卵用
	println!();
     if let Ok(length) = fields[1].parse::<i32>() {   // 强制转换   字符串转为   i32  整型
         // 输出到标准输出
         println!("{:?}, {:?}cm", name, length  );
		print_type_of(&length,String::from("fields[1]【&str 强转成功 】"),fields[1] );
		println!("rawste{}【{}】strarr[0][2]={}, strarr[1][2]={}  ____strarr[1][2]={} 可以强制转换____ " ,i,record , name, fields[1] , fields[1]  );
        println!();
     } else {
		   print_type_of(&fields[1],String::from("fields[1]【&str 强转失败 】"),fields[1]);
		   println!("rawste{}【{}】strarr[0][2]={}, strarr[1][2]={}  ____strarr[1][2]={} 无法强制转换____ " ,i,record , name, fields[1] , fields[1]  );
           println!();	
	}
   }
 }


fn print_type_of<T>( _ : &T ,  tip :  String , mValue : &str ) {    //   分别传递 String 和 &str   类型的参数
    println!("{}____{}____{}", std::any::type_name::<T>() ,&tip, String::from(mValue))
}


/*
程序输出:
i32____fields[1]【&str 强转成功 】____33
rawste1【   Little penguin  ,   33】strarr[0][2]=Little penguin, strarr[1][2]=33  ____strarr[1][2]=33 可以强制转换____


"Yellow-eyed penguin", 65cm
i32____fields[1]【&str 强转成功 】____65
rawste2【   Yellow-eyed penguin  ,   65】strarr[0][2]=Yellow-eyed penguin, strarr[1][2]=65  ____strarr[1][2]=65 可以强制转换____


"Fiordland penguin", 60cm
i32____fields[1]【&str 强转成功 】____60
rawste3【   Fiordland penguin,  60】strarr[0][2]=Fiordland penguin, strarr[1][2]=60  ____strarr[1][2]=60 可以强制转换____


&str____fields[1]【&str 强转失败 】____data
rawste4【   Invalid,data】strarr[0][2]=Invalid, strarr[1][2]=data  ____strarr[1][2]=data 无法强制转换____
*/




```



#### 4_截取子字符串SubString


##### 5_Java
```


public class String_Java_BlockCode {

	
	// 包前不包后
    static String subString(String valueStr,int begin){
        return subString(valueStr,begin,valueStr!=null?valueStr.length():0);
     }

     static String subString(String valueStr,int begin , int end){
         String subString = null;
         if(valueStr == null || begin < 0 || end < 0 || begin > valueStr.length() || end > valueStr.length()){
             return subString;
         }
         subString = valueStr.substring(begin,end);
         return subString;
     }
     
	
     public static void main(String[] args) {
		String num_str = "12345678";
		String num_678_str =  subString(num_str,5,8);
		System.out.println("num_678_str = "+ num_678_str);
		
		String num_12_str =  subString(num_str,0,2);
		System.out.println("num_12_str = "+ num_12_str);
		
	}
	
}

/*打印输出:
 * num_678_str = 678 
 * num_12_str = 12
 */

```





##### 5_Bat


##### 5_Rust



#### 4_判断字符串是否是数字

##### 5_Java

```

public class String_Java_BlockCode {

	
    public static boolean isNumStr(String str){
        if(str == null){
            return false;
        }
        return str.matches("^[-+]?(([0-9]+)([.]([0-9]+))?|([.]([0-9]+))?)$");
    }
    
    
     public static void main(String[] args) {
		String num_str = "12345678";
		boolean num_str_flag = isNumStr(num_str);

		String num_str_1 = "a12345678";
		boolean num_str_1_flag = isNumStr(num_str_1);
		
		System.out.println("num_str="+num_str+"  num_str_flag = "+ num_str_flag);
		System.out.println("num_str_1="+num_str_1+"  num_str_1_flag = "+ num_str_1_flag);
	}
	
}

/*打印输出:
 * num_str=12345678       num_str_flag   = true
 * num_str_1=a12345678    num_str_1_flag = false
 */



```



#### 4_判断字符串是否是字母非数字开头

##### 5_Java

```

public class String_Java_BlockCode {

	
    public static boolean isZiMuBegin(String str){
        if(str == null){
            return false;
        }
        return str.matches("^[a-z,A-Z].*$");
    }
    
    
     public static void main(String[] args) {
		String word_str_1 = "12345678";
		boolean word_str_1_flag = isZiMuBegin(word_str_1);

		String word_str_2 = "dfa12av";
		boolean word_str_2_flag = isZiMuBegin(word_str_2);
		
		String word_str_3 = "abcdef";
		boolean word_str_3_flag = isZiMuBegin(word_str_3);
		
		
	
		System.out.println("word_str_1="+word_str_1+"  word_str_1_flag = "+ word_str_1_flag);
		System.out.println("word_str_2="+word_str_2+"  word_str_2_flag = "+ word_str_2_flag);
		System.out.println("word_str_3="+word_str_3+"  word_str_3_flag = "+ word_str_3_flag);
		
     }
	
}

/*打印输出:
 * word_str_1=12345678  word_str_1_flag = false
 * word_str_2=dfa12av   word_str_2_flag = true
 * word_str_3=abcdef    word_str_3_flag = true
 */




```



#### 4_判断字符串是否包含汉字

##### 5_Java

```

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class String_Java_BlockCode {

	public static boolean isContainChinese(String str) {
		if (str == null) {
			return false;
		}
		Pattern p = Pattern.compile("[\u4e00-\u9fa5]");
		Matcher m = p.matcher(str);
		if (m.find()) {
			return true;
		}
		return false;
	}

	public static void main(String[] args) {
		String word_str_1 = "12345678";
		boolean word_str_1_flag = isContainChinese(word_str_1);

		String word_str_2 = "dfa世界和平12av";
		boolean word_str_2_flag = isContainChinese(word_str_2);

		System.out.println("word_str_1=" + word_str_1 + "  word_str_1_flag = " + word_str_1_flag);
		System.out.println("word_str_2=" + word_str_2 + "  word_str_2_flag = " + word_str_2_flag);

	}

}

/*
 * 打印输出: 
 * word_str_1=12345678      word_str_1_flag = false
 * word_str_2=dfa世界和平12av  word_str_2_flag = true
 */

```


#### 4_填充补齐字符串

##### 5_Java

```


public class String_Java_BlockCode {

	static String getPaddingString(String srcStr, int padinglength, String oneStr, boolean dirPre) {
		String result = "" + srcStr;
		int length = ("" + srcStr).length();
		if (length < padinglength) {
			int distance = padinglength - length;
			for (int i = 0; i < distance; i++) {
				if (dirPre) {
					result = oneStr + result;
				} else {
					result = result + oneStr;
				}
			}
		}
		return result;
	}

	public static void main(String[] args) {
		String word_str_1 = "1";
		String word_str_2 = "11";
		String word_str_3 = "33";

		String word_str_1_paddingstr_pre = getPaddingString(word_str_1, 5, "0", true);
		String word_str_2_paddingstr_pre = getPaddingString(word_str_2, 5, "0", true);
		String word_str_3_paddingstr_pre = getPaddingString(word_str_3, 5, "0", true);

		String word_str_1_paddingstr_tail = getPaddingString(word_str_1, 5, "0", false);
		String word_str_2_paddingstr_tail = getPaddingString(word_str_2, 5, "0", false);
		String word_str_3_paddingstr_tail = getPaddingString(word_str_3, 5, "0", false);

		System.out.println("word_str_1_paddingstr_pre=" + word_str_1_paddingstr_pre + "  word_str_1_paddingstr_tail = "+ word_str_1_paddingstr_tail);
		System.out.println("word_str_2_paddingstr_pre=" + word_str_2_paddingstr_pre + "  word_str_2_paddingstr_tail = "+ word_str_2_paddingstr_tail);
		System.out.println("word_str_3_paddingstr_pre=" + word_str_3_paddingstr_pre + "  word_str_3_paddingstr_tail = "+ word_str_3_paddingstr_tail);

	}

}

/*
 * 打印输出: 
 * word_str_1_paddingstr_pre=00001    word_str_1_paddingstr_tail = 10000
 * word_str_2_paddingstr_pre=00011    word_str_2_paddingstr_tail = 11000
 * word_str_3_paddingstr_pre=00033    word_str_3_paddingstr_tail = 33000
 */


```



### 3_文件系统System操作

#### 4_读取文件到字符串

##### 5_Java

```

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;

public class File_Java_BlockCode {

	public static String readFileContent(File mFilePath) {
		if (mFilePath == null || !mFilePath.exists()) {
			System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());
			return null;
		}
		StringBuilder sb = new StringBuilder();
		try {
			BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
			String oldOneLine = "";
			int index = 1;
			while (oldOneLine != null) {
				oldOneLine = curBR.readLine();
				if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
					continue;
				}
				sb.append(oldOneLine + "\n");
				index++;
			}
			curBR.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	public static void main(String[] args) {

		File tempFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"+ File.separator + "zbin" + File.separator + "I9_Temp_Text.txt");

		String file_content = readFileContent(tempFile);

		System.out.println("file_content=\n" + file_content);
	}

}

/*
 * 打印输出: 
 * file_content=
 * Hello-世界!
 */



```

#### 4_写入文件字符串


##### 5_Java

```

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class File_Java_BlockCode {

	public static String readFileContent(File mFilePath) {
		if (mFilePath == null || !mFilePath.exists()) {
			System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());
			return null;
		}
		StringBuilder sb = new StringBuilder();
		try {
			BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
			String oldOneLine = "";
			int index = 1;
			while (oldOneLine != null) {
				oldOneLine = curBR.readLine();
				if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
					continue;
				}
				sb.append(oldOneLine + "\n");
				index++;
			}
			curBR.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	static void writeContentToFile(File file, String strParam) {
		try {
			if (file != null && !file.exists()) {
				file.createNewFile();
			}
			if (file != null && file.exists()) {
				BufferedWriter curBW = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "utf-8"));
				curBW.write(strParam);
				curBW.flush();
				curBW.close();
			} else {
				System.out.println("write out File  Failed !    File = " + file.getAbsolutePath());
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {

		File tempFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator + "I9_Temp_Text.txt");

		String file_content = readFileContent(tempFile);
		System.out.println("file_content=\n" + file_content);

		String new_content = "World-Peace";
		writeContentToFile(tempFile, new_content);

		String file_file_content = readFileContent(tempFile);
		System.out.println("file_file_content=\n" + file_file_content);

	}

}

/*
 * 打印输出: 
 * file_content=
 * Hello-世界!
 * 
 * file_file_content=
 * World-Peace
 */

```



#### 4_复制文件

##### 5_Java

```


import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

public class File_Java_BlockCode {

    public static void fileCopy(File origin, File target) {
        InputStream input = null;
        OutputStream output = null;
        int lengthSize;
        try {
            input = new FileInputStream(origin);      // 创建输入输出流对象
            output = new FileOutputStream(target);
            try {
                lengthSize = input.available();  // 获取文件长度
                byte[] buffer = new byte[lengthSize];        // 创建缓存区域
                input.read(buffer);      // 将文件中的数据写入缓存数组
                output.write(buffer);      // 将缓存数组中的数据输出到文件
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (input != null && output != null) {
                try {
                    input.close(); // 关闭流
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
	public static void main(String[] args) {

		File srcFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator + "I9_Temp_Text.txt");


		File dstFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + srcFile.getName());

		fileCopy(srcFile,dstFile);
		
		if(dstFile.exists()) {
			System.out.println("复制文件 src["+srcFile.getAbsolutePath()+"]  To  dst["+dstFile.getAbsolutePath()+"]"+"成功!");
		}else {
			System.out.println("复制文件 src["+srcFile.getAbsolutePath()+"]  To  dst["+dstFile.getAbsolutePath()+"]"+"失败!");
		}
	}

}

/*
 * 打印输出: 
 * 复制文件 src[C:\Users\zhuzj5\Desktop\zbin\I9_Temp_Text.txt]  To  dst[C:\Users\zhuzj5\Desktop\I9_Temp_Text.txt]成功!
 */




```



#### 4_获取所有子文件&文件夹

##### 5_Java

```

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;



public class File_Java_BlockCode {

    // 获取所有子文件夹目录的方法
    static ArrayList<File> getAllSubDirFile(File  rootPath) {
        ArrayList<File> allDirFile = new ArrayList<File>();
        Path curRootPath = Paths.get(rootPath.getAbsolutePath() + File.separator );
        try {
            Files.walkFileTree(curRootPath, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                    allDirFile.add(dir.toFile());
                    return super.postVisitDirectory(dir, exc);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return allDirFile;
    }
    // 获取所有子文件夹下实体文件目录的方法
    static ArrayList<File> getAllSubRealFile(File  rootPath) {
        ArrayList<File> allSubFile = new ArrayList<File>();
        Path curRootPath = Paths.get(rootPath.getAbsolutePath() + File.separator );
        try {
            Files.walkFileTree(curRootPath, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String fileString = file.toAbsolutePath().toString();
                    File curFile =    new File(fileString);
                    if(curFile.exists() && curFile.isFile()){
                        allSubFile.add(curFile);
                    }
                    return  FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return allSubFile;
    }
    
	public static void main(String[] args) {

		File zbin_Dir_File = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator );

		
		ArrayList<File>  zbin_all_dirList = getAllSubDirFile(zbin_Dir_File);
		for (int i = 0; i < zbin_all_dirList.size(); i++) {
			File dir_item = zbin_all_dirList.get(i);
			System.out.println("dir["+i+"]["+zbin_all_dirList.size()+"]___"+dir_item.getAbsolutePath());
		}
		

		ArrayList<File>  zbin_all_fileList = getAllSubRealFile(zbin_Dir_File);
		
		for (int i = 0; i < zbin_all_fileList.size(); i++) {
			File file_item = zbin_all_fileList.get(i);
			System.out.println("realfile["+i+"]["+zbin_all_fileList.size()+"]___"+file_item.getAbsolutePath());
		}
		
		System.out.println("zbin_all_dirList.size()="+zbin_all_dirList.size()+"   "+"zbin_all_fileList.size()="+zbin_all_fileList.size());
		
	}

}

/*
 * 打印输出: 
 * 
 * dir[0][720]  ___C:\Users\zhu\Desktop\zbin\and_zbin\and_zbin
 * dir[719][720]___C:\Users\zhu\Desktop\zbin
 * 
 * realfile[0][6265]___C:\Users\zhu\Desktop\zbin\1_mp4_all_2x3.html
 * realfile[6264][6265]___C:\Users\zhu\Desktop\zbin\Z_TEMP.txt
 * 
 * zbin_all_dirList.size()=720   zbin_all_fileList.size()=6265
 */



```



#### 4_获取文件的创建时间

##### 5_Java
```

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;



public class File_Java_BlockCode {

	static String long_2_yyyyMMdd_HHmmss(long millionMs) {

	      Calendar mCalendar=Calendar.getInstance();
	      mCalendar.setTimeInMillis(millionMs);
	      int year = mCalendar.get(Calendar.YEAR);
	      int month = mCalendar.get(Calendar.MONTH);
	      int day = mCalendar.get(Calendar.DAY_OF_MONTH);

	      Date date = mCalendar.getTime();
	      SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
	      String date_str = sdf.format(date);
			return date_str;
		}
	
    static Long getFileCreateTime(File fileItem) {
        if (fileItem == null || !fileItem.exists()) {
            return 0L;
        }
        try {
            Path path = Paths.get(fileItem.getAbsolutePath());
            BasicFileAttributeView basicview = Files.getFileAttributeView(path, BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
            BasicFileAttributes attr = basicview.readAttributes();
            return attr.creationTime().toMillis();
        } catch (Exception e) {
            e.printStackTrace();
            return fileItem.lastModified();
        }
    }
    
    
	public static void main(String[] args) {

		File zbin_Temp_File = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator +"I9_Temp_Text.txt");

		long file_create_time_long = getFileCreateTime(zbin_Temp_File);
		
		System.out.println("file_create_time_long="+file_create_time_long +"  long时间戳 = "+ long_2_yyyyMMdd_HHmmss(file_create_time_long));

	}

}

/*
 * 打印输出: 
 * 
 * file_create_time_long=1616552042481  long时间戳 = 20210324_101402

 */


```


#### 4_获取当前系统名称




##### 5_Java

##### 5_Bat


##### 5_Rust



### 3_时间操作


#### 4_获取当前时间戳 YYYYMMDD_hhmmss



##### 5_Java

```

import java.text.SimpleDateFormat;
import java.util.Date;

public class Time_Java_BlockCode {

	static String getTimeStamp_yyyyMMdd_HHmmss() {
		SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
		String date = df.format(new Date());
		return date;
	}

	public static void main(String[] args) {
		
		String mTime_Stamp_yyyyMMdd_HHmmss = getTimeStamp_yyyyMMdd_HHmmss();

		System.out.println("mTime_Stamp_yyyyMMdd_HHmmss =" + mTime_Stamp_yyyyMMdd_HHmmss);

	}

}

/*
 * 打印输出: 
 * mTime_Stamp_yyyyMMdd_HHmmss =20221012_153418
 */


```

#### 4_Long转为时间戳字符串

##### 5_Java

```

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class Time_Java_BlockCode {

	static String long_2_yyyyMMdd_HHmmss(long millionMs) {

		Calendar mCalendar = Calendar.getInstance();
		mCalendar.setTimeInMillis(millionMs);
		int year = mCalendar.get(Calendar.YEAR);
		int month = mCalendar.get(Calendar.MONTH);
		int day = mCalendar.get(Calendar.DAY_OF_MONTH);

		Date date = mCalendar.getTime();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
		String date_str = sdf.format(date);
		return date_str;
	}

	Calendar endCalendar = Calendar.getInstance();

	public static void main(String[] args) {

		long now_timestamp_long = System.currentTimeMillis();
		String now_timestamp_yyyyMMdd_HHmmss = long_2_yyyyMMdd_HHmmss(now_timestamp_long);

		System.out.println("now_timestamp_long =" + now_timestamp_long + "   now_timestamp_yyyyMMdd_HHmmss="+ now_timestamp_yyyyMMdd_HHmmss);

	}

}

/*
 * 打印输出: now_timestamp_long =1665563597143   now_timestamp_yyyyMMdd_HHmmss=20221012_163317
 */


```

##### 5_Bat


##### 5_Rust



### 3_Map结构体操作


#### 4_遍历Map




##### 5_Java

```

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class Map_Java_BlockCode {

	@SuppressWarnings("unchecked")
	public static void showKeyAndValue(Map<String, String> mMapParam) {
		Map.Entry<String, String> entryItem;
		int item_index = 0;
		int map_size = 0;
		if (mMapParam != null) {
			map_size = mMapParam.size();
			Iterator iterator = mMapParam.entrySet().iterator();
			while (iterator.hasNext()) {
				entryItem = (Map.Entry<String, String>) iterator.next();
				String key = entryItem.getKey(); // Map的Key
				String value = entryItem.getValue(); // Map的Value
				System.out.println("map[" + item_index + "][" + map_size + "]____" + "key[" + key + "]-value[" + value + "]");
				item_index++;
			}
		}
	}

	public static void main(String[] args) {
		HashMap<String, String> stringMap = new HashMap<String, String>();
		stringMap.put("a", "1");
		stringMap.put("b", "2");
		stringMap.put("c", "3");
		stringMap.put("d", "4");
		stringMap.put("e", "5");
		stringMap.put("f", "6");
		showKeyAndValue(stringMap);

	}

}

/*
 * 打印输出: 
 * map[0][6]____key[a]-value[1]
 * map[1][6]____key[b]-value[2]
 * map[2][6]____key[c]-value[3]
 * map[3][6]____key[d]-value[4]
 * map[4][6]____key[e]-value[5]
 * map[5][6]____key[f]-value[6]
 */



```



##### 5_Bat


##### 5_Rust



