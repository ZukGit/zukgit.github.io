---
layout: post
title: 代码区块
category: 代码
tags: 代码
keywords: 代码  
typora-root-url: ..\..\
typora-copy-images-to: ..\..\public\zimage
---

## 2_简介
 * TOC
 {:toc}
 
## 2_代码区块


### 基础数据类型_整型_浮点_字符_布尔


#### 整型操作


##### Rust 

```
int_macros.rs   提供的方法

1 pub const fn count_ones(self) -> u32 【】
2 pub const fn count_zeros(self) -> u32 【】
3 pub const fn leading_zeros(self) -> u32 【】
4 pub const fn trailing_zeros(self) -> u32 【】
5 pub const fn leading_ones(self) -> u32 【】
6 pub const fn trailing_ones(self) -> u32 【】
7 pub const fn rotate_left(self, n: u32) -> Self 【】
8 pub const fn rotate_right(self, n: u32) -> Self 【】
9 pub const fn swap_bytes(self) -> Self 【】
10 pub const fn reverse_bits(self) -> Self 【】
11 pub const fn from_be(x: Self) -> Self 【】
12 pub const fn from_le(x: Self) -> Self 【】
13 pub const fn to_be(self) -> Self 【】 // or not to be?
14 pub const fn to_le(self) -> Self 【】
15 pub const fn checked_add(self, rhs: Self) -> Option<Self> 【】
16 pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> 【】
17 pub const fn checked_sub(self, rhs: Self) -> Option<Self> 【】
18 pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> 【】
19 pub const fn checked_mul(self, rhs: Self) -> Option<Self> 【】
20 pub const fn checked_div(self, rhs: Self) -> Option<Self> 【】
21 pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> 【】
22 pub const fn checked_rem(self, rhs: Self) -> Option<Self> 【】
23 pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> 【】
24 pub const fn checked_neg(self) -> Option<Self> 【】
25 pub const fn checked_shl(self, rhs: u32) -> Option<Self> 【】
26 pub const fn checked_shr(self, rhs: u32) -> Option<Self> 【】
27 pub const fn checked_abs(self) -> Option<Self> 【】
28 pub const fn checked_pow(self, mut exp: u32) -> Option<Self> 【】
29 pub const fn saturating_add(self, rhs: Self) -> Self 【】
30 pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self 【】
31 pub const fn saturating_sub(self, rhs: Self) -> Self 【】
32 pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self 【】
33 pub const fn saturating_neg(self) -> Self 【】
34 pub const fn saturating_abs(self) -> Self 【】
35 pub const fn saturating_mul(self, rhs: Self) -> Self 【】
36 pub const fn saturating_div(self, rhs: Self) -> Self 【】
37 pub const fn saturating_pow(self, exp: u32) -> Self 【】
38 pub const fn wrapping_add(self, rhs: Self) -> Self 【】
39 pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self 【】
40 pub const fn wrapping_sub(self, rhs: Self) -> Self 【】
41 pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self 【】
42 pub const fn wrapping_mul(self, rhs: Self) -> Self 【】
43 pub const fn wrapping_div(self, rhs: Self) -> Self 【】
44 pub const fn wrapping_div_euclid(self, rhs: Self) -> Self 【】
45 pub const fn wrapping_rem(self, rhs: Self) -> Self 【】
46 pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self 【】
47 pub const fn wrapping_neg(self) -> Self 【】
48 pub const fn wrapping_shl(self, rhs: u32) -> Self 【】
49 pub const fn wrapping_shr(self, rhs: u32) -> Self 【】
50 pub const fn wrapping_abs(self) -> Self 【】
51 pub const fn unsigned_abs(self) -> $UnsignedT 【】
52 pub const fn wrapping_pow(self, mut exp: u32) -> Self 【】
53 pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) 【】
54 pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) 【】
55 pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) 【】
56 pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) 【】
57 pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) 【】
58 pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) 【】
59 pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) 【】
60 pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) 【】
61 pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) 【】
62 pub const fn overflowing_neg(self) -> (Self, bool) 【】
63 pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) 【】
64 pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) 【】
65 pub const fn overflowing_abs(self) -> (Self, bool) 【】
66 pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) 【】
67 pub const fn pow(self, mut exp: u32) -> Self 【】
68 pub const fn div_euclid(self, rhs: Self) -> Self 【】
69 pub const fn rem_euclid(self, rhs: Self) -> Self 【】
70 pub const fn div_floor(self, rhs: Self) -> Self 【】
71 pub const fn div_ceil(self, rhs: Self) -> Self 【】
72 pub const fn next_multiple_of(self, rhs: Self) -> Self 【】
73 pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> 【】
74 pub const fn log(self, base: Self) -> u32 【】
75 pub const fn log2(self) -> u32 【】
76 pub const fn log10(self) -> u32 【】
77 pub const fn checked_log(self, base: Self) -> Option<u32> 【】
78 pub const fn checked_log2(self) -> Option<u32> 【】
79 pub const fn checked_log10(self) -> Option<u32> 【】
80 pub const fn abs(self) -> Self 【】
81 pub const fn abs_diff(self, other: Self) -> $UnsignedT 【】
82 pub const fn signum(self) -> Self 【】
83 pub const fn is_positive(self) -> bool 【】 self > 0 }
84 pub const fn is_negative(self) -> bool 【】 self < 0 }
85 pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] 【】
86 pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] 【】
87 pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] 【】
88 pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self 【】
89 pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self 【】
90 pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self 【】
91 pub const fn min_value() -> Self 【】
92 pub const fn max_value() -> Self 【】




```


Rust i32 i64 验证方法代码区块
 

```


fn get_var_type<T>( _ : &T   ) -> &str {    
 std::any::type_name::<T>()
}


fn main() {
println!();
	println!("int 打印 二进制格式");
	let ijk: (i32, i32, i32) = (30, 60, 90);
//  println!("ijk.0={}   bit={:x}",ijk.0,ijk.0.to_bits());    //  报错: i32 没有对应的 to_bits() 方法  只有浮点类型有这个方法
    println!("ijk【{}】 {:?}",get_var_type(&ijk),ijk);                    //  {:?} 打印详细集合元素
	println!("ijk.0={}   二进制打印  bit= {:b} ",ijk.0,ijk.0);  // {:b} 打印 2进制  输出显示 显示
	println!("ijk.0={}   八进制打印 ijk.0={:o}  ",ijk.0,ijk.0);  // {:o} 打印 8进制  输出显示
	println!("ijk.0={}   十进制打印 ijk.0={}  ",ijk.0,ijk.0);          // {} 十进制打印
	println!("ijk.0={}   十六进制打印  ijk.0=={:x}  ",ijk.0,ijk.0);    // {:x} 打印 16进制  输出
			
  
  	println!("ijk.0={}   bit={:b}",ijk.0,ijk.0);
  	println!("ijk.1={}   bit={:b}",ijk.1,ijk.1);
    println!("ijk.2={}   bit={:b}",ijk.2,ijk.2);
    println!("     0.1 + 0.2: {:x}", (ijk.0 + ijk.1));
    println!("           0.3: {:x}", (ijk.2));
    println!();
}


```



#### f32_f64浮点类型

##### Rust 

```
f32.rs   f64.rs  定义的方法
1 pub const fn is_nan(self) -> bool 【】
2 pub const fn is_infinite(self) -> bool 【】
3 pub const fn is_finite(self) -> bool 【】
4 pub const fn is_subnormal(self) -> bool 【】
5 pub const fn is_normal(self) -> bool 【】
6 pub const fn classify(self) -> FpCategory 【】
7 pub const fn is_sign_positive(self) -> bool 【】
8 pub const fn is_sign_negative(self) -> bool 【】
9 pub const fn to_bits(self) -> u32 【】
10 pub const fn from_bits(v: u32) -> Self 【】
11 pub const fn to_be_bytes(self) -> [u8; 4] 【】
12 pub const fn to_le_bytes(self) -> [u8; 4] 【】
13 pub const fn to_ne_bytes(self) -> [u8; 4] 【】
14 pub const fn from_be_bytes(bytes: [u8; 4]) -> Self 【】
15 pub const fn from_le_bytes(bytes: [u8; 4]) -> Self 【】
16 pub const fn from_ne_bytes(bytes: [u8; 4]) -> Self 【】

```



Rust f32 f64 验证方法代码区块

```




```



#### 字符类型

##### Rust字符 

```
mod.rs 定义的字符char函数

1 pub const fn widening_mul(self, rhs: Self) -> (Self, Self) 【】
2 pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) 【】
3 pub const fn is_ascii(&self) -> bool 【】
4 pub const fn to_ascii_uppercase(&self) -> u8 【】
5 pub const fn to_ascii_lowercase(&self) -> u8 【】
6 pub const fn eq_ignore_ascii_case(&self, other: &u8) -> bool 【】
7 pub const fn is_ascii_alphabetic(&self) -> bool 【】
8 pub const fn is_ascii_uppercase(&self) -> bool 【】
9 pub const fn is_ascii_lowercase(&self) -> bool 【】
10 pub const fn is_ascii_alphanumeric(&self) -> bool 【】
11 pub const fn is_ascii_digit(&self) -> bool 【】
12 pub const fn is_ascii_hexdigit(&self) -> bool 【】
13 pub const fn is_ascii_punctuation(&self) -> bool 【】
14 pub const fn is_ascii_graphic(&self) -> bool 【】
15 pub const fn is_ascii_whitespace(&self) -> bool 【】
16 pub const fn is_ascii_control(&self) -> bool 【】
17 pub const fn is_utf16_surrogate(self) -> bool 【】



```




Rust f32 f64 验证方法代码区块

```




```



### 系统库函数

#### 运行时库函数



##### Rust 


###### rust\library\std\src\env.rs

```

1 pub fn current_dir() -> io::Result<PathBuf> 【】
2 pub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> 【】
3 pub fn vars() -> Vars 【】
4 pub fn vars_os() -> VarsOs 【】
5 pub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> 【】
6 pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> 【】
7 pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(key: K, value: V) 【】
8 pub fn remove_var<K: AsRef<OsStr>>(key: K) 【】
9 pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths<'_> 【】
10 pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
11 pub fn home_dir() -> Option<PathBuf> 【】
12 pub fn temp_dir() -> PathBuf 【】
13 pub fn current_exe() -> io::Result<PathBuf> 【】
14 pub fn args() -> Args 【】
15 pub fn args_os() -> ArgsOs 【】


```

###### /rust/library/core/src/mem/mod.rs
```
std::mem::size_of_val(&T)


1 pub const fn forget<T>(t: T) 【】
2 pub const fn size_of<T>() -> usize 【】
3 pub const fn size_of_val<T: ?Sized>(val: &T) -> usize 【】
4 pub const fn align_of<T>() -> usize 【】
5 pub const fn align_of_val<T: ?Sized>(val: &T) -> usize 【】
6 pub const fn needs_drop<T: ?Sized>() -> bool 【】
7 pub const fn swap<T>(x: &mut T, y: &mut T) 【】
8 pub const fn replace<T>(dest: &mut T, src: T) -> T 【】
9 pub const fn discriminant<T>(v: &T) -> Discriminant<T> 【】
10 pub const fn variant_count<T>() -> usize 【】
11 pub fn forget_unsized<T: ?Sized>(t: T) 【】
12 pub fn min_align_of<T>() -> usize 【】
13 pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize 【】
14 pub fn take<T: Default>(dest: &mut T) -> T 【】
15 pub fn drop<T>(_x: T) 【】}
16 pub fn copy<T: Copy>(x: &T) -> T 【】


 

```
###### /rust/library/core/src/any.rs

```
1 pub const fn of<T: ?Sized + 'static>() -> TypeId 【】
2 pub const fn type_name<T: ?Sized>() -> &'static str 【】
3 pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str 【】
4 pub fn is<T: Any>(&self) -> bool 【】
5 pub fn downcast_ref<T: Any>(&self) -> Option<&T> 【】
6 pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> 【】
7 pub fn is<T: Any>(&self) -> bool 【】
8 pub fn downcast_ref<T: Any>(&self) -> Option<&T> 【】
9 pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> 【】
10 pub fn is<T: Any>(&self) -> bool 【】
11 pub fn downcast_ref<T: Any>(&self) -> Option<&T> 【】
12 pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> 【】
13 pub fn request_value<'a, T, P>(provider: &'a P) -> Option<T>
14 pub fn request_ref<'a, T, P>(provider: &'a P) -> Option<&'a T>
15 pub fn provide_value<T, F>(&mut self, fulfil: F) -> &mut Self
16 pub fn provide_ref<T: ?Sized + 'static>(&mut self, value: &'a T) -> &mut Self 【】

	


```

###### rust\library\std\src\sys\windows\os.rs

```
1 pub fn errno() -> i32 【】
2 pub fn error_string(mut errnum: i32) -> String 【】
3 pub fn env() -> Env 【】
4 pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> 【】
5 pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
6 pub fn current_exe() -> io::Result<PathBuf> 【】
7 pub fn getcwd() -> io::Result<PathBuf> 【】
8 pub fn chdir(p: &path::Path) -> io::Result<()> 【】
9 pub fn getenv(k: &OsStr) -> Option<OsString> 【】
10 pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> 【】
11 pub fn unsetenv(n: &OsStr) -> io::Result<()> 【】
12 pub fn temp_dir() -> PathBuf 【】
13 pub fn home_dir() -> Option<PathBuf> 【】
14 pub fn exit(code: i32) -> ! 【】
15 pub fn getpid() -> u32 【】



```




###### rust\library\std\src\sys\windows\process.rs

```
1 pub fn new(program: &OsStr) -> Command 【】
2 pub fn arg(&mut self, arg: &OsStr) 【】
3 pub fn env_mut(&mut self) -> &mut CommandEnv 【】
4 pub fn cwd(&mut self, dir: &OsStr) 【】
5 pub fn stdin(&mut self, stdin: Stdio) 【】
6 pub fn stdout(&mut self, stdout: Stdio) 【】
7 pub fn stderr(&mut self, stderr: Stdio) 【】
8 pub fn creation_flags(&mut self, flags: u32) 【】
9 pub fn force_quotes(&mut self, enabled: bool) 【】
10 pub fn raw_arg(&mut self, command_str_to_append: &OsStr) 【】
11 pub fn get_program(&self) -> &OsStr 【】
12 pub fn get_args(&self) -> CommandArgs<'_> 【】
13 pub fn get_envs(&self) -> CommandEnvs<'_> 【】
14 pub fn get_current_dir(&self) -> Option<&Path> 【】
15 pub fn spawn(
16 pub fn kill(&mut self) -> io::Result<()> 【】
17 pub fn id(&self) -> u32 【】
18 pub fn main_thread_handle(&self) -> BorrowedHandle<'_> 【】
19 pub fn wait(&mut self) -> io::Result<ExitStatus> 【】
20 pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> 【】
21 pub fn handle(&self) -> &Handle 【】
22 pub fn into_handle(self) -> Handle 【】
23 pub fn exit_ok(&self) -> Result<(), ExitStatusError> 【】
24 pub fn code(&self) -> Option<i32> 【】
25 pub fn code(self) -> Option<NonZeroI32> 【】
26 pub fn as_i32(&self) -> i32 【】


```





### 3_String字符串操作



#### 字符串函数列表

##### Rust 

###### /rust/library/core/src/str/mod.rs

```

1 pub const fn len(&self) -> usize 【】
2 pub const fn is_empty(&self) -> bool 【】
3 pub const fn is_char_boundary(&self, index: usize) -> bool 【】
4 pub const fn as_bytes(&self) -> &[u8] 【】
5 pub const fn as_ptr(&self) -> *const u8 【】
6 pub const fn get<I: ~const SliceIndex<str>>(&self, i: I) -> Option<&I::Output> 【】
7 pub const fn get_mut<I: ~const SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> 【】
8 pub fn floor_char_boundary(&self, index: usize) -> usize 【】
9 pub fn ceil_char_boundary(&self, index: usize) -> usize 【】
10 pub fn as_mut_ptr(&mut self) -> *mut u8 【】
11 pub fn split_at(&self, mid: usize) -> (&str, &str) 【】
12 pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) 【】
13 pub fn chars(&self) -> Chars<'_> 【】
14 pub fn char_indices(&self) -> CharIndices<'_> 【】
15 pub fn bytes(&self) -> Bytes<'_> 【】
16 pub fn split_whitespace(&self) -> SplitWhitespace<'_> 【】
17 pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace<'_> 【】
18 pub fn lines(&self) -> Lines<'_> 【】
19 pub fn lines_any(&self) -> LinesAny<'_> 【】
20 pub fn encode_utf16(&self) -> EncodeUtf16<'_> 【】
21 pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 【】
22 pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 【】
23 pub fn ends_with<'a, P>(&'a self, pat: P) -> bool
24 pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> 【】
25 pub fn rfind<'a, P>(&'a self, pat: P) -> Option<usize>
26 pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> 【】
27 pub fn split_inclusive<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitInclusive<'a, P> 【】
28 pub fn rsplit<'a, P>(&'a self, pat: P) -> RSplit<'a, P>
29 pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> 【】
30 pub fn rsplit_terminator<'a, P>(&'a self, pat: P) -> RSplitTerminator<'a, P>
31 pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> 【】
32 pub fn rsplitn<'a, P>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>
33 pub fn split_once<'a, P: Pattern<'a>>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)> 【】
34 pub fn rsplit_once<'a, P>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)>
35 pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> 【】
36 pub fn rmatches<'a, P>(&'a self, pat: P) -> RMatches<'a, P>
37 pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> 【】
38 pub fn rmatch_indices<'a, P>(&'a self, pat: P) -> RMatchIndices<'a, P>
39 pub fn trim(&self) -> &str 【】
40 pub fn trim_start(&self) -> &str 【】
41 pub fn trim_end(&self) -> &str 【】
42 pub fn trim_left(&self) -> &str 【】
43 pub fn trim_right(&self) -> &str 【】
44 pub fn trim_matches<'a, P>(&'a self, pat: P) -> &'a str
45 pub fn trim_start_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str 【】
46 pub fn strip_prefix<'a, P: Pattern<'a>>(&'a self, prefix: P) -> Option<&'a str> 【】
47 pub fn strip_suffix<'a, P>(&'a self, suffix: P) -> Option<&'a str>
48 pub fn trim_end_matches<'a, P>(&'a self, pat: P) -> &'a str
49 pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str 【】
50 pub fn trim_right_matches<'a, P>(&'a self, pat: P) -> &'a str
51 pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> 【】
52 pub fn is_ascii(&self) -> bool 【】
53 pub fn eq_ignore_ascii_case(&self, other: &str) -> bool 【】
54 pub fn make_ascii_uppercase(&mut self) 【】
55 pub fn make_ascii_lowercase(&mut self) 【】
56 pub fn escape_debug(&self) -> EscapeDebug<'_> 【】
57 pub fn escape_default(&self) -> EscapeDefault<'_> 【】
58 pub fn escape_unicode(&self) -> EscapeUnicode<'_> 【】


```

###### /rust/library/alloc/src/str.rs


```

1 pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> 【】
2 pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String 【】
3 pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String 【】
4 pub fn to_lowercase(&self) -> String 【】
5 pub fn to_uppercase(&self) -> String 【】
6 pub fn into_string(self: Box<str>) -> String 【】
7 pub fn repeat(&self, n: usize) -> String 【】
8 pub fn to_ascii_uppercase(&self) -> String 【】
9 pub fn to_ascii_lowercase(&self) -> String 【】





```

######  rust\library\std\src\sys\windows\os_str.rs

```

1 pub fn with_capacity(capacity: usize) -> Buf 【】
2 pub fn clear(&mut self) 【】
3 pub fn capacity(&self) -> usize 【】
4 pub fn from_string(s: String) -> Buf 【】
5 pub fn as_slice(&self) -> &Slice 【】
6 pub fn as_mut_slice(&mut self) -> &mut Slice 【】
7 pub fn into_string(self) -> Result<String, Buf> 【】
8 pub fn push_slice(&mut self, s: &Slice) 【】
9 pub fn reserve(&mut self, additional: usize) 【】
10 pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> 【】
11 pub fn reserve_exact(&mut self, additional: usize) 【】
12 pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> 【】
13 pub fn shrink_to_fit(&mut self) 【】
14 pub fn shrink_to(&mut self, min_capacity: usize) 【】
15 pub fn into_box(self) -> Box<Slice> 【】
16 pub fn from_box(boxed: Box<Slice>) -> Buf 【】
17 pub fn into_arc(&self) -> Arc<Slice> 【】
18 pub fn into_rc(&self) -> Rc<Slice> 【】
19 pub fn from_str(s: &str) -> &Slice 【】
20 pub fn to_str(&self) -> Option<&str> 【】
21 pub fn to_string_lossy(&self) -> Cow<'_, str> 【】
22 pub fn to_owned(&self) -> Buf 【】
23 pub fn clone_into(&self, buf: &mut Buf) 【】
24 pub fn into_box(&self) -> Box<Slice> 【】
25 pub fn empty_box() -> Box<Slice> 【】
26 pub fn into_arc(&self) -> Arc<Slice> 【】
27 pub fn into_rc(&self) -> Rc<Slice> 【】
28 pub fn make_ascii_lowercase(&mut self) 【】
29 pub fn make_ascii_uppercase(&mut self) 【】
30 pub fn to_ascii_lowercase(&self) -> Buf 【】
31 pub fn to_ascii_uppercase(&self) -> Buf 【】
32 pub fn is_ascii(&self) -> bool 【】
33 pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool 【】






```




###### /rust/library/alloc/src/string.rs

```
1 pub const fn new() -> String 【】
2 pub fn with_capacity(capacity: usize) -> String 【】
3 pub fn from_str(_: &str) -> String 【】
4 pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> 【】
5 pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> 【】
6 pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> 【】
7 pub fn from_utf16_lossy(v: &[u16]) -> String 【】
8 pub fn into_raw_parts(self) -> (*mut u8, usize, usize) 【】
9 pub fn into_bytes(self) -> Vec<u8> 【】
10 pub fn as_str(&self) -> &str 【】
11 pub fn as_mut_str(&mut self) -> &mut str 【】
12 pub fn push_str(&mut self, string: &str) 【】
13 pub fn extend_from_within<R>(&mut self, src: R)
14 pub fn capacity(&self) -> usize 【】
15 pub fn reserve(&mut self, additional: usize) 【】
16 pub fn reserve_exact(&mut self, additional: usize) 【】
17 pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> 【】
18 pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> 【】
19 pub fn shrink_to_fit(&mut self) 【】
20 pub fn shrink_to(&mut self, min_capacity: usize) 【】
21 pub fn push(&mut self, ch: char) 【】
22 pub fn as_bytes(&self) -> &[u8] 【】
23 pub fn truncate(&mut self, new_len: usize) 【】
24 pub fn pop(&mut self) -> Option<char> 【】
25 pub fn remove(&mut self, idx: usize) -> char 【】
26 pub fn remove_matches<'a, P>(&'a mut self, pat: P)
27 pub fn retain<F>(&mut self, mut f: F)
28 pub fn insert(&mut self, idx: usize, ch: char) 【】
29 pub fn insert_str(&mut self, idx: usize, string: &str) 【】
30 pub fn len(&self) -> usize 【】
31 pub fn is_empty(&self) -> bool 【】
32 pub fn split_off(&mut self, at: usize) -> String 【】
33 pub fn clear(&mut self) 【】
34 pub fn drain<R>(&mut self, range: R) -> Drain<'_>
35 pub fn replace_range<R>(&mut self, range: R, replace_with: &str)
36 pub fn into_boxed_str(self) -> Box<str> 【】
37 pub fn as_bytes(&self) -> &[u8] 【】
38 pub fn into_bytes(self) -> Vec<u8> 【】
39 pub fn utf8_error(&self) -> Utf8Error 【】
40 pub fn as_str(&self) -> &str 【】




```






#### 4_强制转换整型

##### 5_Rust

```

fn main() {
   let penguin_data = "\
   common name  ,length (cm)
   Little penguin  ,   33
   Yellow-eyed penguin  ,   65
   Fiordland penguin,  60
   Invalid,data
   ";

   let records = penguin_data.lines();  //  这里返回的行的迭代器 iteration  

   for (i, record) in records.enumerate() {   // iteration 只能读取到value , 不能读取到索引  ,  iteration.enumerate() 就能读取到索引以及对应的value
     if i == 0 || record.trim().len() == 0 {  // i ==0 把 第一行  common name  ,length (cm) 过滤掉了
       continue;
     }

     // 声明一个 fields 变量，类型是 Vec
     // Vec 是 vector 的缩写，是一个可伸缩的集合类型，可以认为是一个动态数组
     // <_>表示 Vec 中的元素类型由编译器自行推断，在很多场景下，都会帮我们省却不少功夫
     let fields: Vec<_> = record
       .split(',')
       .map(|field| field.trim())
       .collect();
     if cfg!(debug_assertions) {
         // 输出到标准错误输出
       //   eprintln!("debug: {:?} -> {:?}", record, fields);
     }

     let name = fields[0];
     // 1. 尝试把 fields[1] 的值转换为 f32 类型的浮点数，如果成功，则把 f32 值赋给 length 变量
     //
     // 2. if let 是一个匹配表达式，用来从=右边的结果中，匹配出 length 的值：
     //   1）当=右边的表达式执行成功，则会返回一个 Ok(f32) 的类型，若失败，则会返回一个 Err(e) 类型，if let 的作用就是仅匹配 Ok 也就是成功的情况，如果是错误，就直接忽略
     //   2）同时 if let 还会做一次解构匹配，通过 Ok(length) 去匹配右边的 Ok(f32)，最终把相应的 f32 值赋给 length
     //
     // 3. 当然你也可以忽略成功的情况，用 if let Err(e) = fields[1].parse::<f32>() {...}匹配出错误，然后打印出来，但是没啥卵用
	println!();
     if let Ok(length) = fields[1].parse::<i32>() {   // 强制转换   字符串转为   i32  整型
         // 输出到标准输出
         println!("{:?}, {:?}cm", name, length  );
		print_type_of(&length,String::from("fields[1]【&str 强转成功 】"),fields[1] );
		println!("rawste{}【{}】strarr[0][2]={}, strarr[1][2]={}  ____strarr[1][2]={} 可以强制转换____ " ,i,record , name, fields[1] , fields[1]  );
        println!();
     } else {
		   print_type_of(&fields[1],String::from("fields[1]【&str 强转失败 】"),fields[1]);
		   println!("rawste{}【{}】strarr[0][2]={}, strarr[1][2]={}  ____strarr[1][2]={} 无法强制转换____ " ,i,record , name, fields[1] , fields[1]  );
           println!();	
	}
   }
 }


fn print_type_of<T>( _ : &T ,  tip :  String , mValue : &str ) {    //   分别传递 String 和 &str   类型的参数
    println!("{}____{}____{}", std::any::type_name::<T>() ,&tip, String::from(mValue))
}


/*
程序输出:
i32____fields[1]【&str 强转成功 】____33
rawste1【   Little penguin  ,   33】strarr[0][2]=Little penguin, strarr[1][2]=33  ____strarr[1][2]=33 可以强制转换____


"Yellow-eyed penguin", 65cm
i32____fields[1]【&str 强转成功 】____65
rawste2【   Yellow-eyed penguin  ,   65】strarr[0][2]=Yellow-eyed penguin, strarr[1][2]=65  ____strarr[1][2]=65 可以强制转换____


"Fiordland penguin", 60cm
i32____fields[1]【&str 强转成功 】____60
rawste3【   Fiordland penguin,  60】strarr[0][2]=Fiordland penguin, strarr[1][2]=60  ____strarr[1][2]=60 可以强制转换____


&str____fields[1]【&str 强转失败 】____data
rawste4【   Invalid,data】strarr[0][2]=Invalid, strarr[1][2]=data  ____strarr[1][2]=data 无法强制转换____
*/




```



#### 4_截取子字符串SubString


##### 5_Java
```


public class String_Java_BlockCode {

	
	// 包前不包后
    static String subString(String valueStr,int begin){
        return subString(valueStr,begin,valueStr!=null?valueStr.length():0);
     }

     static String subString(String valueStr,int begin , int end){
         String subString = null;
         if(valueStr == null || begin < 0 || end < 0 || begin > valueStr.length() || end > valueStr.length()){
             return subString;
         }
         subString = valueStr.substring(begin,end);
         return subString;
     }
     
	
     public static void main(String[] args) {
		String num_str = "12345678";
		String num_678_str =  subString(num_str,5,8);
		System.out.println("num_678_str = "+ num_678_str);
		
		String num_12_str =  subString(num_str,0,2);
		System.out.println("num_12_str = "+ num_12_str);
		
	}
	
}

/*打印输出:
 * num_678_str = 678 
 * num_12_str = 12
 */

```





##### 5_Bat


##### 5_Rust



#### 4_判断字符串是否是数字

##### 5_Java

```

public class String_Java_BlockCode {

	
    public static boolean isNumStr(String str){
        if(str == null){
            return false;
        }
        return str.matches("^[-+]?(([0-9]+)([.]([0-9]+))?|([.]([0-9]+))?)$");
    }
    
    
     public static void main(String[] args) {
		String num_str = "12345678";
		boolean num_str_flag = isNumStr(num_str);

		String num_str_1 = "a12345678";
		boolean num_str_1_flag = isNumStr(num_str_1);
		
		System.out.println("num_str="+num_str+"  num_str_flag = "+ num_str_flag);
		System.out.println("num_str_1="+num_str_1+"  num_str_1_flag = "+ num_str_1_flag);
	}
	
}

/*打印输出:
 * num_str=12345678       num_str_flag   = true
 * num_str_1=a12345678    num_str_1_flag = false
 */



```



#### 4_判断字符串是否是字母非数字开头

##### 5_Java

```

public class String_Java_BlockCode {

	
    public static boolean isZiMuBegin(String str){
        if(str == null){
            return false;
        }
        return str.matches("^[a-z,A-Z].*$");
    }
    
    
     public static void main(String[] args) {
		String word_str_1 = "12345678";
		boolean word_str_1_flag = isZiMuBegin(word_str_1);

		String word_str_2 = "dfa12av";
		boolean word_str_2_flag = isZiMuBegin(word_str_2);
		
		String word_str_3 = "abcdef";
		boolean word_str_3_flag = isZiMuBegin(word_str_3);
		
		
	
		System.out.println("word_str_1="+word_str_1+"  word_str_1_flag = "+ word_str_1_flag);
		System.out.println("word_str_2="+word_str_2+"  word_str_2_flag = "+ word_str_2_flag);
		System.out.println("word_str_3="+word_str_3+"  word_str_3_flag = "+ word_str_3_flag);
		
     }
	
}

/*打印输出:
 * word_str_1=12345678  word_str_1_flag = false
 * word_str_2=dfa12av   word_str_2_flag = true
 * word_str_3=abcdef    word_str_3_flag = true
 */




```



#### 4_判断字符串是否包含汉字

##### 5_Java

```

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class String_Java_BlockCode {

	public static boolean isContainChinese(String str) {
		if (str == null) {
			return false;
		}
		Pattern p = Pattern.compile("[\u4e00-\u9fa5]");
		Matcher m = p.matcher(str);
		if (m.find()) {
			return true;
		}
		return false;
	}

	public static void main(String[] args) {
		String word_str_1 = "12345678";
		boolean word_str_1_flag = isContainChinese(word_str_1);

		String word_str_2 = "dfa世界和平12av";
		boolean word_str_2_flag = isContainChinese(word_str_2);

		System.out.println("word_str_1=" + word_str_1 + "  word_str_1_flag = " + word_str_1_flag);
		System.out.println("word_str_2=" + word_str_2 + "  word_str_2_flag = " + word_str_2_flag);

	}

}

/*
 * 打印输出: 
 * word_str_1=12345678      word_str_1_flag = false
 * word_str_2=dfa世界和平12av  word_str_2_flag = true
 */

```


#### 4_填充补齐字符串

##### 5_Java

```


public class String_Java_BlockCode {

	static String getPaddingString(String srcStr, int padinglength, String oneStr, boolean dirPre) {
		String result = "" + srcStr;
		int length = ("" + srcStr).length();
		if (length < padinglength) {
			int distance = padinglength - length;
			for (int i = 0; i < distance; i++) {
				if (dirPre) {
					result = oneStr + result;
				} else {
					result = result + oneStr;
				}
			}
		}
		return result;
	}

	public static void main(String[] args) {
		String word_str_1 = "1";
		String word_str_2 = "11";
		String word_str_3 = "33";

		String word_str_1_paddingstr_pre = getPaddingString(word_str_1, 5, "0", true);
		String word_str_2_paddingstr_pre = getPaddingString(word_str_2, 5, "0", true);
		String word_str_3_paddingstr_pre = getPaddingString(word_str_3, 5, "0", true);

		String word_str_1_paddingstr_tail = getPaddingString(word_str_1, 5, "0", false);
		String word_str_2_paddingstr_tail = getPaddingString(word_str_2, 5, "0", false);
		String word_str_3_paddingstr_tail = getPaddingString(word_str_3, 5, "0", false);

		System.out.println("word_str_1_paddingstr_pre=" + word_str_1_paddingstr_pre + "  word_str_1_paddingstr_tail = "+ word_str_1_paddingstr_tail);
		System.out.println("word_str_2_paddingstr_pre=" + word_str_2_paddingstr_pre + "  word_str_2_paddingstr_tail = "+ word_str_2_paddingstr_tail);
		System.out.println("word_str_3_paddingstr_pre=" + word_str_3_paddingstr_pre + "  word_str_3_paddingstr_tail = "+ word_str_3_paddingstr_tail);

	}

}

/*
 * 打印输出: 
 * word_str_1_paddingstr_pre=00001    word_str_1_paddingstr_tail = 10000
 * word_str_2_paddingstr_pre=00011    word_str_2_paddingstr_tail = 11000
 * word_str_3_paddingstr_pre=00033    word_str_3_paddingstr_tail = 33000
 */


```



### 3_文件系统System操作

#### 4_读取文件到字符串

##### 5_Java

```

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;

public class File_Java_BlockCode {

	public static String readFileContent(File mFilePath) {
		if (mFilePath == null || !mFilePath.exists()) {
			System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());
			return null;
		}
		StringBuilder sb = new StringBuilder();
		try {
			BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
			String oldOneLine = "";
			int index = 1;
			while (oldOneLine != null) {
				oldOneLine = curBR.readLine();
				if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
					continue;
				}
				sb.append(oldOneLine + "\n");
				index++;
			}
			curBR.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	public static void main(String[] args) {

		File tempFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"+ File.separator + "zbin" + File.separator + "I9_Temp_Text.txt");

		String file_content = readFileContent(tempFile);

		System.out.println("file_content=\n" + file_content);
	}

}

/*
 * 打印输出: 
 * file_content=
 * Hello-世界!
 */



```

#### 4_写入文件字符串


##### 5_Java

```

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class File_Java_BlockCode {

	public static String readFileContent(File mFilePath) {
		if (mFilePath == null || !mFilePath.exists()) {
			System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());
			return null;
		}
		StringBuilder sb = new StringBuilder();
		try {
			BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
			String oldOneLine = "";
			int index = 1;
			while (oldOneLine != null) {
				oldOneLine = curBR.readLine();
				if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
					continue;
				}
				sb.append(oldOneLine + "\n");
				index++;
			}
			curBR.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	static void writeContentToFile(File file, String strParam) {
		try {
			if (file != null && !file.exists()) {
				file.createNewFile();
			}
			if (file != null && file.exists()) {
				BufferedWriter curBW = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "utf-8"));
				curBW.write(strParam);
				curBW.flush();
				curBW.close();
			} else {
				System.out.println("write out File  Failed !    File = " + file.getAbsolutePath());
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {

		File tempFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator + "I9_Temp_Text.txt");

		String file_content = readFileContent(tempFile);
		System.out.println("file_content=\n" + file_content);

		String new_content = "World-Peace";
		writeContentToFile(tempFile, new_content);

		String file_file_content = readFileContent(tempFile);
		System.out.println("file_file_content=\n" + file_file_content);

	}

}

/*
 * 打印输出: 
 * file_content=
 * Hello-世界!
 * 
 * file_file_content=
 * World-Peace
 */

```



#### 4_复制文件

##### 5_Java

```


import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

public class File_Java_BlockCode {

    public static void fileCopy(File origin, File target) {
        InputStream input = null;
        OutputStream output = null;
        int lengthSize;
        try {
            input = new FileInputStream(origin);      // 创建输入输出流对象
            output = new FileOutputStream(target);
            try {
                lengthSize = input.available();  // 获取文件长度
                byte[] buffer = new byte[lengthSize];        // 创建缓存区域
                input.read(buffer);      // 将文件中的数据写入缓存数组
                output.write(buffer);      // 将缓存数组中的数据输出到文件
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (input != null && output != null) {
                try {
                    input.close(); // 关闭流
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
	public static void main(String[] args) {

		File srcFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator + "I9_Temp_Text.txt");


		File dstFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + srcFile.getName());

		fileCopy(srcFile,dstFile);
		
		if(dstFile.exists()) {
			System.out.println("复制文件 src["+srcFile.getAbsolutePath()+"]  To  dst["+dstFile.getAbsolutePath()+"]"+"成功!");
		}else {
			System.out.println("复制文件 src["+srcFile.getAbsolutePath()+"]  To  dst["+dstFile.getAbsolutePath()+"]"+"失败!");
		}
	}

}

/*
 * 打印输出: 
 * 复制文件 src[C:\Users\zhuzj5\Desktop\zbin\I9_Temp_Text.txt]  To  dst[C:\Users\zhuzj5\Desktop\I9_Temp_Text.txt]成功!
 */




```



#### 4_获取所有子文件&文件夹

##### 5_Java

```

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;



public class File_Java_BlockCode {

    // 获取所有子文件夹目录的方法
    static ArrayList<File> getAllSubDirFile(File  rootPath) {
        ArrayList<File> allDirFile = new ArrayList<File>();
        Path curRootPath = Paths.get(rootPath.getAbsolutePath() + File.separator );
        try {
            Files.walkFileTree(curRootPath, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                    allDirFile.add(dir.toFile());
                    return super.postVisitDirectory(dir, exc);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return allDirFile;
    }
    // 获取所有子文件夹下实体文件目录的方法
    static ArrayList<File> getAllSubRealFile(File  rootPath) {
        ArrayList<File> allSubFile = new ArrayList<File>();
        Path curRootPath = Paths.get(rootPath.getAbsolutePath() + File.separator );
        try {
            Files.walkFileTree(curRootPath, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String fileString = file.toAbsolutePath().toString();
                    File curFile =    new File(fileString);
                    if(curFile.exists() && curFile.isFile()){
                        allSubFile.add(curFile);
                    }
                    return  FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return allSubFile;
    }
    
	public static void main(String[] args) {

		File zbin_Dir_File = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator );

		
		ArrayList<File>  zbin_all_dirList = getAllSubDirFile(zbin_Dir_File);
		for (int i = 0; i < zbin_all_dirList.size(); i++) {
			File dir_item = zbin_all_dirList.get(i);
			System.out.println("dir["+i+"]["+zbin_all_dirList.size()+"]___"+dir_item.getAbsolutePath());
		}
		

		ArrayList<File>  zbin_all_fileList = getAllSubRealFile(zbin_Dir_File);
		
		for (int i = 0; i < zbin_all_fileList.size(); i++) {
			File file_item = zbin_all_fileList.get(i);
			System.out.println("realfile["+i+"]["+zbin_all_fileList.size()+"]___"+file_item.getAbsolutePath());
		}
		
		System.out.println("zbin_all_dirList.size()="+zbin_all_dirList.size()+"   "+"zbin_all_fileList.size()="+zbin_all_fileList.size());
		
	}

}

/*
 * 打印输出: 
 * 
 * dir[0][720]  ___C:\Users\zhu\Desktop\zbin\and_zbin\and_zbin
 * dir[719][720]___C:\Users\zhu\Desktop\zbin
 * 
 * realfile[0][6265]___C:\Users\zhu\Desktop\zbin\1_mp4_all_2x3.html
 * realfile[6264][6265]___C:\Users\zhu\Desktop\zbin\Z_TEMP.txt
 * 
 * zbin_all_dirList.size()=720   zbin_all_fileList.size()=6265
 */



```



#### 4_获取文件的创建时间

##### 5_Java
```

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;



public class File_Java_BlockCode {

	static String long_2_yyyyMMdd_HHmmss(long millionMs) {

	      Calendar mCalendar=Calendar.getInstance();
	      mCalendar.setTimeInMillis(millionMs);
	      int year = mCalendar.get(Calendar.YEAR);
	      int month = mCalendar.get(Calendar.MONTH);
	      int day = mCalendar.get(Calendar.DAY_OF_MONTH);

	      Date date = mCalendar.getTime();
	      SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
	      String date_str = sdf.format(date);
			return date_str;
		}
	
    static Long getFileCreateTime(File fileItem) {
        if (fileItem == null || !fileItem.exists()) {
            return 0L;
        }
        try {
            Path path = Paths.get(fileItem.getAbsolutePath());
            BasicFileAttributeView basicview = Files.getFileAttributeView(path, BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
            BasicFileAttributes attr = basicview.readAttributes();
            return attr.creationTime().toMillis();
        } catch (Exception e) {
            e.printStackTrace();
            return fileItem.lastModified();
        }
    }
    
    
	public static void main(String[] args) {

		File zbin_Temp_File = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
				+ File.separator + "zbin" + File.separator +"I9_Temp_Text.txt");

		long file_create_time_long = getFileCreateTime(zbin_Temp_File);
		
		System.out.println("file_create_time_long="+file_create_time_long +"  long时间戳 = "+ long_2_yyyyMMdd_HHmmss(file_create_time_long));

	}

}

/*
 * 打印输出: 
 * 
 * file_create_time_long=1616552042481  long时间戳 = 20210324_101402

 */


```


#### 4_获取当前系统名称




##### 5_Java

##### 5_Bat


##### 5_Rust

###### rust\library\std\src\sys\windows\fs.rs

```

1 pub fn path(&self) -> PathBuf 【】
2 pub fn file_name(&self) -> OsString 【】
3 pub fn file_type(&self) -> io::Result<FileType> 【】
4 pub fn metadata(&self) -> io::Result<FileAttr> 【】
5 pub fn new() -> OpenOptions 【】
6 pub fn read(&mut self, read: bool) 【】
7 pub fn write(&mut self, write: bool) 【】
8 pub fn append(&mut self, append: bool) 【】
9 pub fn truncate(&mut self, truncate: bool) 【】
10 pub fn create(&mut self, create: bool) 【】
11 pub fn create_new(&mut self, create_new: bool) 【】
12 pub fn custom_flags(&mut self, flags: u32) 【】
13 pub fn access_mode(&mut self, access_mode: u32) 【】
14 pub fn share_mode(&mut self, share_mode: u32) 【】
15 pub fn attributes(&mut self, attrs: u32) 【】
16 pub fn security_qos_flags(&mut self, flags: u32) 【】
17 pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) 【】
18 pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 【】
19 pub fn fsync(&self) -> io::Result<()> 【】
20 pub fn datasync(&self) -> io::Result<()> 【】
21 pub fn truncate(&self, size: u64) -> io::Result<()> 【】
22 pub fn file_attr(&self) -> io::Result<FileAttr> 【】
23 pub fn file_attr(&self) -> io::Result<FileAttr> 【】
24 pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 【】
25 pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> 【】
26 pub fn is_read_vectored(&self) -> bool 【】
27 pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 【】
28 pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> 【】
29 pub fn write(&self, buf: &[u8]) -> io::Result<usize> 【】
30 pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> 【】
31 pub fn is_write_vectored(&self) -> bool 【】
32 pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> 【】
33 pub fn flush(&self) -> io::Result<()> 【】
34 pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 【】
35 pub fn duplicate(&self) -> io::Result<File> 【】
36 pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> 【】
37 pub fn size(&self) -> u64 【】
38 pub fn perm(&self) -> FilePermissions 【】
39 pub fn attrs(&self) -> u32 【】
40 pub fn file_type(&self) -> FileType 【】
41 pub fn modified(&self) -> io::Result<SystemTime> 【】
42 pub fn accessed(&self) -> io::Result<SystemTime> 【】
43 pub fn created(&self) -> io::Result<SystemTime> 【】
44 pub fn modified_u64(&self) -> u64 【】
45 pub fn accessed_u64(&self) -> u64 【】
46 pub fn created_u64(&self) -> u64 【】
47 pub fn volume_serial_number(&self) -> Option<u32> 【】
48 pub fn number_of_links(&self) -> Option<u32> 【】
49 pub fn file_index(&self) -> Option<u64> 【】
50 pub fn readonly(&self) -> bool 【】
51 pub fn set_readonly(&mut self, readonly: bool) 【】
52 pub fn is_dir(&self) -> bool 【】
53 pub fn is_file(&self) -> bool 【】
54 pub fn is_symlink(&self) -> bool 【】
55 pub fn is_symlink_dir(&self) -> bool 【】
56 pub fn is_symlink_file(&self) -> bool 【】
57 pub fn new() -> DirBuilder 【】
58 pub fn mkdir(&self, p: &Path) -> io::Result<()> 【】
59 pub fn readdir(p: &Path) -> io::Result<ReadDir> 【】
60 pub fn unlink(p: &Path) -> io::Result<()> 【】
61 pub fn rename(old: &Path, new: &Path) -> io::Result<()> 【】
62 pub fn rmdir(p: &Path) -> io::Result<()> 【】
63 pub fn remove_dir_all(path: &Path) -> io::Result<()> 【】
64 pub fn readlink(path: &Path) -> io::Result<PathBuf> 【】
65 pub fn symlink(original: &Path, link: &Path) -> io::Result<()> 【】
66 pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()> 【】
67 pub fn link(original: &Path, link: &Path) -> io::Result<()> 【】
68 pub fn link(_original: &Path, _link: &Path) -> io::Result<()> 【】
69 pub fn stat(path: &Path) -> io::Result<FileAttr> 【】
70 pub fn lstat(path: &Path) -> io::Result<FileAttr> 【】
71 pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 【】
72 pub fn canonicalize(p: &Path) -> io::Result<PathBuf> 【】
73 pub fn copy(from: &Path, to: &Path) -> io::Result<u64> 【】
74 pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(
75 pub fn try_exists(path: &Path) -> io::Result<bool> 【】


```


### 3_时间操作


#### 4_获取当前时间戳 YYYYMMDD_hhmmss



##### 5_Java

```

import java.text.SimpleDateFormat;
import java.util.Date;

public class Time_Java_BlockCode {

	static String getTimeStamp_yyyyMMdd_HHmmss() {
		SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
		String date = df.format(new Date());
		return date;
	}

	public static void main(String[] args) {
		
		String mTime_Stamp_yyyyMMdd_HHmmss = getTimeStamp_yyyyMMdd_HHmmss();

		System.out.println("mTime_Stamp_yyyyMMdd_HHmmss =" + mTime_Stamp_yyyyMMdd_HHmmss);

	}

}

/*
 * 打印输出: 
 * mTime_Stamp_yyyyMMdd_HHmmss =20221012_153418
 */


```

#### 4_Long转为时间戳字符串

##### 5_Java

```

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class Time_Java_BlockCode {

	static String long_2_yyyyMMdd_HHmmss(long millionMs) {

		Calendar mCalendar = Calendar.getInstance();
		mCalendar.setTimeInMillis(millionMs);
		int year = mCalendar.get(Calendar.YEAR);
		int month = mCalendar.get(Calendar.MONTH);
		int day = mCalendar.get(Calendar.DAY_OF_MONTH);

		Date date = mCalendar.getTime();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
		String date_str = sdf.format(date);
		return date_str;
	}

	Calendar endCalendar = Calendar.getInstance();

	public static void main(String[] args) {

		long now_timestamp_long = System.currentTimeMillis();
		String now_timestamp_yyyyMMdd_HHmmss = long_2_yyyyMMdd_HHmmss(now_timestamp_long);

		System.out.println("now_timestamp_long =" + now_timestamp_long + "   now_timestamp_yyyyMMdd_HHmmss="+ now_timestamp_yyyyMMdd_HHmmss);

	}

}

/*
 * 打印输出: now_timestamp_long =1665563597143   now_timestamp_yyyyMMdd_HHmmss=20221012_163317
 */


```

##### 5_Bat


##### 5_Rust

###### \rust\library\std\src\time.rs
```
\rust\library\std\src\time.rs 定义的函数

1 pub fn now() -> Instant 【】
2 pub fn duration_since(&self, earlier: Instant) -> Duration 【】
3 pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> 【】
4 pub fn saturating_duration_since(&self, earlier: Instant) -> Duration 【】
5 pub fn elapsed(&self) -> Duration 【】
6 pub fn checked_add(&self, duration: Duration) -> Option<Instant> 【】
7 pub fn checked_sub(&self, duration: Duration) -> Option<Instant> 【】
8 pub fn now() -> SystemTime 【】
9 pub fn duration_since(&self, earlier: SystemTime) -> Result<Duration, SystemTimeError> 【】
10 pub fn elapsed(&self) -> Result<Duration, SystemTimeError> 【】
11 pub fn checked_add(&self, duration: Duration) -> Option<SystemTime> 【】
12 pub fn checked_sub(&self, duration: Duration) -> Option<SystemTime> 【】
13 pub fn duration(&self) -> Duration 【】



```


### 3_Array结构体操作


##### Array方法

###### Rust 


####### rust\library\core\src\array\mod.rs

```

1 pub const fn from_ref<T>(s: &T) -> &[T; 1] 【】
2 pub const fn from_mut<T>(s: &mut T) -> &mut [T; 1] 【】
3 pub const fn as_slice(&self) -> &[T] 【】
4 pub fn from_fn<T, const N: usize, F>(mut cb: F) -> [T; N]
5 pub fn try_from_fn<R, const N: usize, F>(cb: F) -> ChangeOutputType<R, [R::Output; N]>
6 pub fn __description(&self) -> &str 【】
7 pub fn map<F, U>(self, f: F) -> [U; N]
8 pub fn try_map<F, R>(self, f: F) -> ChangeOutputType<R, [R::Output; N]>
9 pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] 【】
10 pub fn as_mut_slice(&mut self) -> &mut [T] 【】
11 pub fn each_ref(&self) -> [&T; N] 【】
12 pub fn each_mut(&mut self) -> [&mut T; N] 【】
13 pub fn split_array_ref<const M: usize>(&self) -> (&[T; M], &[T]) 【】
14 pub fn split_array_mut<const M: usize>(&mut self) -> (&mut [T; M], &mut [T]) 【】
15 pub fn rsplit_array_ref<const M: usize>(&self) -> (&[T], &[T; M]) 【】
16 pub fn rsplit_array_mut<const M: usize>(&mut self) -> (&mut [T], &mut [T; M]) 【】




```

####### rust\library\core\src\array\iter.rs 
```

1 pub const unsafe fn new_unchecked【】
2 pub const fn empty() -> Self 【】
3 pub fn new(array: [T; N]) -> Self 【】
4 pub const unsafe fn new_unchecked(
5 pub const fn empty() -> Self 【】
6 pub fn as_slice(&self) -> &[T] 【】
7 pub fn as_mut_slice(&mut self) -> &mut [T] 【】
8 fn next(&mut self) -> Option<Self::Item> 【】
9 fn size_hint(&self) -> (usize, Option<usize>) 【】
10 fn fold<Acc, Fold>(mut self, init: Acc, mut fold: Fold) -> Acc
11 fn count(self) -> usize 【】
12 fn last(mut self) -> Option<Self::Item> 【】
13 fn advance_by(&mut self, n: usize) -> Result<(), usize> 【】
14 fn next_back(&mut self) -> Option<Self::Item> 【】
15 fn rfold<Acc, Fold>(mut self, init: Acc, mut rfold: Fold) -> Acc
16 fn advance_back_by(&mut self, n: usize) -> Result<(), usize> 【】
17 fn drop(&mut self) 【】
18 fn len(&self) -> usize 【】
19 fn is_empty(&self) -> bool 【】
20 fn clone(&self) -> Self 【】
21 fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 【】


```


### 3_Map结构体操作






#### 4_遍历Map




##### 5_Java

```

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class Map_Java_BlockCode {

	@SuppressWarnings("unchecked")
	public static void showKeyAndValue(Map<String, String> mMapParam) {
		Map.Entry<String, String> entryItem;
		int item_index = 0;
		int map_size = 0;
		if (mMapParam != null) {
			map_size = mMapParam.size();
			Iterator iterator = mMapParam.entrySet().iterator();
			while (iterator.hasNext()) {
				entryItem = (Map.Entry<String, String>) iterator.next();
				String key = entryItem.getKey(); // Map的Key
				String value = entryItem.getValue(); // Map的Value
				System.out.println("map[" + item_index + "][" + map_size + "]____" + "key[" + key + "]-value[" + value + "]");
				item_index++;
			}
		}
	}

	public static void main(String[] args) {
		HashMap<String, String> stringMap = new HashMap<String, String>();
		stringMap.put("a", "1");
		stringMap.put("b", "2");
		stringMap.put("c", "3");
		stringMap.put("d", "4");
		stringMap.put("e", "5");
		stringMap.put("f", "6");
		showKeyAndValue(stringMap);

	}

}

/*
 * 打印输出: 
 * map[0][6]____key[a]-value[1]
 * map[1][6]____key[b]-value[2]
 * map[2][6]____key[c]-value[3]
 * map[3][6]____key[d]-value[4]
 * map[4][6]____key[e]-value[5]
 * map[5][6]____key[f]-value[6]
 */



```



##### 5_Bat


##### 5_Rust



